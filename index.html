<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape"
    />
    <title>éƒ½é“åºœçœŒwar</title>
    <style>
      /* === å…¨ä½“è¨­å®š === */
      body {
        background: #080808;
        color: #e0e0e0;
        font-family: "Yu Gothic UI", "Meiryo", sans-serif;
        margin: 0;
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
      }

      /* === ãƒˆãƒƒãƒ—ãƒãƒ¼ === */
      #topbar {
        display: flex;
        height: 50px;
        background: #181818;
        border-bottom: 1px solid #333;
        align-items: center;
        padding: 0 15px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.9);
        z-index: 20;
        position: relative;
      }
      .flag {
        font-size: 28px;
        margin-right: 15px;
        cursor: pointer;
        transition: 0.2s;
        filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.5));
      }
      .res-grp {
        display: flex;
        gap: 15px;
        margin-right: 20px;
        border-right: 1px solid #444;
        padding-right: 20px;
      }
      @media (max-width: 768px) {
        .res-grp {
          gap: 8px;
          margin-right: 10px;
          padding-right: 10px;
        }
        .res span.val {
          display: none;
        }
        .res-grp:nth-child(3) {
          display: none;
        }
      }
      .res {
        display: flex;
        align-items: center;
        font-size: 13px;
        font-weight: bold;
      }
      .icon {
        width: 14px;
        height: 14px;
        display: inline-block;
        margin-right: 6px;
        border-radius: 3px;
        box-shadow: 0 1px 3px #000;
      }
      .date-box {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 5px;
        background: #222;
        padding: 3px 12px;
        border-radius: 20px;
        border: 1px solid #444;
        color: #fff;
        font-family: monospace;
      }
      .spd-btn {
        background: none;
        border: none;
        color: #666;
        cursor: pointer;
        font-weight: bold;
        padding: 5px 8px;
        transition: 0.2s;
        font-size: 16px;
      }
      .spd-btn.active {
        color: #fff;
        text-shadow: 0 0 5px var(--hl);
      }

      /* === ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ === */
      #game-layout {
        display: flex;
        height: calc(100vh - 50px);
      }
      #sidebar {
        width: 320px;
        background: #121212;
        border-right: 1px solid #333;
        display: flex;
        flex-direction: column;
        z-index: 10;
        box-shadow: 2px 0 15px rgba(0, 0, 0, 0.6);
        transition: transform 0.3s;
      }
      @media (max-width: 600px) {
        #sidebar {
          position: absolute;
          height: 100%;
          transform: translateX(-100%);
          width: 100%;
          max-width: 350px;
        }
        #sidebar.show {
          transform: translateX(0);
        }
      }
      .tabs {
        display: flex;
        height: 45px;
        background: #0e0e0e;
      }
      .tab {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: #666;
        border-bottom: 3px solid transparent;
        font-size: 14px;
        transition: 0.2s;
        font-weight: bold;
        padding: 10px;
      }
      .tab.active {
        color: #fff;
        border-bottom-color: var(--hl);
        background: #1e1e1e;
      }
      .view {
        padding: 20px;
        display: none;
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      .view.active {
        display: block;
      }

      /* === ãƒãƒƒãƒ—ã‚¨ãƒªã‚¢ === */
      #map-wrap {
        flex: 1;
        position: relative;
        overflow: hidden;
        background: #020508;
        cursor: grab;
        touch-action: none;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      /* === ãƒ¦ãƒ‹ãƒƒãƒˆãƒ»UI === */
      .unit-grp {
        cursor: pointer;
        will-change: transform;
      }
      .unit-grp.selected .unit-box {
        stroke: #fff;
        stroke-width: 1.5;
        filter: drop-shadow(0 0 3px #fff);
      }
      .unit-box {
        width: 22px;
        height: 14px;
        fill: #333;
        stroke: #000;
        stroke-width: 1;
      }
      .unit-icon {
        font-size: 10px;
        fill: #fff;
        text-anchor: middle;
        pointer-events: none;
      }
      .unit-bar {
        fill: #00e676;
      }
      .unit-sup-bar {
        fill: #ff9100;
      }
      .unit-inner.fighting .unit-box {
        stroke: #ff5252;
        stroke-width: 2px;
      }
      .no-supply-icon {
        font-size: 12px;
        fill: red;
        font-weight: bold;
        stroke: #000;
        stroke-width: 0.5px;
      }

      /* === ä½œæˆ¦è¨ˆç”»ãƒ©ã‚¤ãƒ³ === */
      .battle-line {
        fill: none;
        stroke: #ffca28;
        stroke-width: 4px;
        stroke-dasharray: 8, 6;
        stroke-linecap: round;
        stroke-linejoin: round;
        opacity: 0.9;
        pointer-events: none;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8));
        animation: dashAnimation 1s linear infinite;
      }
      @keyframes dashAnimation {
        to {
          stroke-dashoffset: -14;
        }
      }

      /* === ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ === */
      #super-event-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        z-index: 20000;
        display: none;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
        cursor: pointer;
      }
      .se-container {
        width: 650px;
        height: 480px;
        background: #000;
        border: 4px solid #888;
        position: relative;
        box-shadow: 0 0 80px rgba(255, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
        max-width: 90%;
        max-height: 80%;
        cursor: auto;
        pointer-events: auto;
      }
      .se-scanlines {
        position: absolute;
        inset: 0;
        background: repeating-linear-gradient(
          transparent 0px,
          transparent 2px,
          rgba(0, 0, 0, 0.6) 4px
        );
        pointer-events: none;
        opacity: 0.5;
        z-index: 5;
        animation: flicker 0.15s infinite;
      }
      @keyframes flicker {
        0% {
          opacity: 0.45;
        }
        50% {
          opacity: 0.55;
        }
        100% {
          opacity: 0.45;
        }
      }
      .se-image-area {
        height: 280px;
        background: #111;
        position: relative;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        border-bottom: 3px solid #fff;
      }
      .se-title-box {
        background: #000;
        color: #fff;
        padding: 10px 0;
        border-top: 3px solid #fff;
        border-bottom: 3px solid #fff;
        margin-top: -30px;
        z-index: 10;
        width: 90%;
        text-align: center;
        margin-left: 5%;
        position: relative;
        box-shadow: 0 0 20px #000;
      }
      .se-title {
        font-family: "MS Mincho", serif;
        font-size: 32px;
        font-weight: 900;
        letter-spacing: 4px;
        text-shadow: 0 0 15px #f00;
        color: #fff;
      }
      .se-quote-box {
        flex: 1;
        padding: 10px 30px;
        color: #fff;
        font-family: "MS Mincho", serif;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        background: #050505;
      }
      .se-quote {
        font-size: 16px;
        margin-bottom: 8px;
        color: #ccc;
        line-height: 1.4;
        font-style: italic;
      }
      .se-author {
        font-size: 12px;
        color: #666;
        align-self: flex-end;
      }
      .se-btn {
        width: 100%;
        padding: 15px;
        background: #ddd;
        color: #000;
        border: none;
        font-family: "MS Mincho", serif;
        font-weight: 900;
        font-size: 18px;
        cursor: pointer;
        transition: 0.2s;
        border-top: 3px solid #555;
        text-transform: uppercase;
      }
      .se-btn:hover {
        background: #fff;
        letter-spacing: 4px;
        color: #b71c1c;
      }

      /* === UIéƒ¨å“ === */
      .btn {
        width: 100%;
        padding: 12px;
        background: linear-gradient(to bottom, #3a3a3a, #252525);
        border: 1px solid #444;
        color: #fff;
        cursor: pointer;
        margin-bottom: 10px;
        border-radius: 2px;
        font-weight: bold;
        text-shadow: 0 1px 2px #000;
        box-shadow: 0 2px 0 #111;
        transition: 0.1s;
        font-size: 14px;
      }
      .btn:hover {
        filter: brightness(1.2);
      }
      .btn-green {
        background: linear-gradient(to bottom, #1b5e20, #003300);
        border-color: #002200;
        color: #81c784;
      }
      .btn-red {
        background: linear-gradient(to bottom, #b71c1c, #7f0000);
        border-color: #5f0000;
        color: #ffcdd2;
      }

      /* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€š */
      .modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 100;
        display: none;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
      }
      .modal-win {
        width: 95%;
        max-width: 1200px;
        height: 90%;
        max-height: 800px;
        background: #1a1a1a;
        border: 1px solid #444;
        display: flex;
        flex-direction: column;
        box-shadow: 0 20px 60px #000;
        border-radius: 4px;
        overflow: hidden;
      }
      .modal-head {
        padding: 10px 20px;
        background: #252525;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #333;
      }

      /* æŠ¼ã—ã‚„ã™ã„é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ */
      .close-btn-lg {
        background: #b71c1c;
        color: #fff;
        font-size: 24px;
        font-weight: bold;
        border: 1px solid #ff5252;
        border-radius: 5px;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
      }
      .close-btn-lg:active {
        transform: scale(0.95);
        background: #f00;
      }

      #focus-modal .modal-body {
        overflow: hidden;
        cursor: grab;
        background: #0a0a0a;
        touch-action: none;
        height: 100%;
      }
      #focus-canvas {
        width: 3000px;
        height: 2000px;
        position: relative;
        background-image: radial-gradient(#333 1px, transparent 1px);
        background-size: 30px 30px;
        transform-origin: 0 0;
      }
      .focus-node {
        position: absolute;
        width: 240px;
        min-height: 90px;
        padding: 12px;
        background: #1f1f1f;
        border: 2px solid #444;
        color: #ccc;
        font-size: 13px;
        cursor: pointer;
        text-align: center;
        z-index: 2;
        border-radius: 2px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.8);
        transition: 0.2s;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      .focus-node:hover {
        transform: scale(1.05);
        z-index: 10;
        border-color: #fff;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
      }
      .focus-node.completed {
        border-color: var(--hl);
        background: #00251a;
        color: #80cbc4;
      }
      .focus-node.available {
        border-color: var(--warn);
        background: #261e05;
        box-shadow: 0 0 10px rgba(253, 216, 53, 0.15);
      }
      .focus-node.locked {
        opacity: 0.4;
        filter: grayscale(1);
        pointer-events: none;
      }
      .focus-node.exclusive-locked {
        border-color: #b71c1c;
        opacity: 0.6;
        filter: grayscale(1);
        pointer-events: none;
        background: #200;
      }
      .focus-lines-svg {
        position: absolute;
        inset: 0;
        pointer-events: none;
        width: 100%;
        height: 100%;
      }

      /* ãƒ‡ã‚¶ã‚¤ãƒŠãƒ¼ï¼ˆã‚¹ãƒãƒ›å¯¾å¿œå¼·åŒ–ï¼‰ */
      .ds-layout {
        display: flex;
        height: 100%;
        overflow: hidden;
      }

      /* å·¦ãƒ‘ãƒãƒ«ï¼ˆãƒªã‚¹ãƒˆï¼‰ */
      .ds-panel {
        width: 250px;
        background: #222;
        border-right: 1px solid #444;
        padding: 15px;
        overflow-y: auto;
        flex-shrink: 0;
      }

      /* å³ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ï¼ˆã‚°ãƒªãƒƒãƒ‰ï¼‰ */
      .ds-main {
        flex: 1;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #181818;
        overflow-y: auto;
      }

      /* ãƒ¢ãƒã‚¤ãƒ«ãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–èª¿æ•´ */
      @media (max-width: 850px) {
        .ds-layout {
          flex-direction: row;
        }
        .ds-panel {
          width: 35%;
          padding: 10px;
        }
        .ds-main {
          padding: 10px;
          width: 65%;
        }
        .ds-grid {
          grid-template-columns: repeat(3, 1fr);
          gap: 5px;
          padding: 10px;
        }
        .slot {
          width: 45px;
          height: 45px;
          font-size: 18px;
        }
        .unit-opt {
          padding: 8px;
          font-size: 11px;
        }
        .unit-opt-icon {
          font-size: 14px;
        }

        /* çµ±è¨ˆæƒ…å ±ã®æ–‡å­—ã‚µã‚¤ã‚ºç¸®å° */
        #ds-stats-box {
          font-size: 11px !important;
        }
      }

      /* ã•ã‚‰ã«å°ã•ã„ç”»é¢ï¼ˆç¸¦æŒã¡ãªã©ï¼‰ */
      @media (max-width: 500px) {
        .ds-layout {
          flex-direction: column-reverse;
        } /* ã‚°ãƒªãƒƒãƒ‰ã‚’ä¸Šã« */
        .ds-panel {
          width: 100%;
          height: 40%;
          border-right: none;
          border-top: 1px solid #444;
        }
        .ds-main {
          width: 100%;
          height: 60%;
        }
      }

      .ds-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin-bottom: 20px;
        background: #252525;
        padding: 15px;
        border-radius: 5px;
        border: 1px solid #333;
      }
      .slot {
        width: 60px;
        height: 60px;
        background: #333;
        border: 1px dashed #555;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        position: relative;
        border-radius: 3px;
        transition: 0.1s;
      }
      .slot.filled {
        border-style: solid;
        border-color: var(--hl);
        background: #2b2b2b;
      }
      .unit-opt {
        padding: 10px;
        background: #333;
        border: 1px solid #444;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 5px;
        border-radius: 3px;
        transition: 0.1s;
      }
      .unit-opt:hover {
        background: #444;
        border-color: #666;
        transform: translateX(3px);
      }

      :root {
        --hl: #00acc1;
        --warn: #ffb300;
        --danger: #e53935;
        --good: #43a047;
      }
      #news-feed {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 300px;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 50;
      }
      @media (max-width: 600px) {
        #news-feed {
          width: 90%;
          right: 5%;
        }
      }
      .news {
        background: rgba(10, 10, 10, 0.95);
        color: #fff;
        padding: 12px 15px;
        border-left: 4px solid #aaa;
        font-size: 13px;
        border-radius: 2px;
        animation: slideIn 0.3s;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
      }
      @keyframes slideIn {
        from {
          transform: translateX(100%);
        }
        to {
          transform: translateX(0);
        }
      }

      #start-screen {
        position: fixed;
        inset: 0;
        background: #050505;
        z-index: 9000;
        display: none;
        flex-direction: column;
        align-items: center;
        padding: 50px;
      }
      .country-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 15px;
        width: 100%;
        max-width: 1200px;
        overflow-y: auto;
        padding-bottom: 50px;
      }
      .country-card {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 5px;
        padding: 15px;
        cursor: pointer;
        transition: 0.2s;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100px;
        justify-content: center;
      }
      .country-card:hover {
        background: #2a2a2a;
        border-color: var(--danger);
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(183, 28, 28, 0.3);
      }

      .sb-profile {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        background: #222;
        padding: 15px;
        border-radius: 5px;
        border: 1px solid #333;
      }
      .focus-btn-custom {
        position: relative;
        height: 60px;
        text-align: left;
        padding-left: 15px;
        background: #1f1f1f;
      }
      .focus-bar-bg {
        position: absolute;
        bottom: 0;
        left: 0;
        height: 4px;
        width: 100%;
        background: #111;
      }
      .focus-bar-progress {
        height: 100%;
        width: 0;
        background: var(--warn);
        transition: 0.2s;
      }

      #select-box {
        position: absolute;
        border: 1px solid #fff;
        background: rgba(255, 255, 255, 0.1);
        display: none;
        pointer-events: none;
        z-index: 10;
      }
      #loading-overlay {
        position: fixed;
        inset: 0;
        background: #000;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #fff;
      }
      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #333;
        border-top-color: var(--danger);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* ä½œæˆ¦ãƒœã‚¿ãƒ³ */
      #btn-plan-mode {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 60px;
        height: 60px;
        background: #333;
        border: 2px solid #555;
        border-radius: 50%;
        color: #fff;
        font-size: 24px;
        display: none; /* é¸æŠæ™‚ã®ã¿è¡¨ç¤º */
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.8);
        cursor: pointer;
        z-index: 900;
        transition: 0.2s;
      }
      #btn-plan-mode.active {
        background: var(--warn);
        color: #000;
        border-color: #fff;
        transform: scale(1.1);
        box-shadow: 0 0 15px var(--warn);
      }
    </style>
  </head>
  <body>
    <!-- ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ -->
    <div id="super-event-overlay" onclick="SuperEvent.close()">
      <div class="se-container" onclick="event.stopPropagation()">
        <div class="se-scanlines"></div>
        <div class="se-image-area" id="se-img-box">
          <div
            style="font-size: 120px; opacity: 0.3; filter: blur(3px)"
            id="se-icon"
          >
            âš ï¸
          </div>
          <div class="se-title-box">
            <div class="se-title" id="se-title">ä»¤å’Œã®æˆ¦å›½æ™‚ä»£ å‹ƒç™º</div>
          </div>
        </div>
        <div class="se-quote-box">
          <div class="se-quote" id="se-quote">
            ã€Œåœ°æ–¹è‡ªæ²»ã¯æ­»ã‚“ã ã€‚ã“ã‚Œã‚ˆã‚ŠåŠ›ã«ã‚ˆã‚‹çµ±æ²»ã‚’è¡Œã†ã€‚ã€
          </div>
          <div class="se-author" id="se-author">- å…¨å›½çŸ¥äº‹ä¼š ç·Šæ€¥å£°æ˜</div>
        </div>
        <button class="se-btn" onclick="SuperEvent.close()" id="se-btn-text">
          å…¨è»ã€é€²æ’ƒã›ã‚ˆã€‚
        </button>
      </div>
    </div>

    <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° -->
    <div id="loading-overlay">
      <div class="spinner"></div>
      <div id="loading-text">æ—¥æœ¬åˆ—å³¶ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
    </div>

    <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ -->
    <div id="start-screen">
      <div
        style="
          font-size: 36px;
          font-weight: bold;
          margin-bottom: 10px;
          color: var(--danger);
          text-align: center;
          letter-spacing: 2px;
          text-shadow: 0 0 10px #500;
        "
      >
        éƒ½é“åºœçœŒå¤§æˆ¦
      </div>
      <div style="color: #aaa; margin-bottom: 40px; text-align: center">
        æŒ‡æ®ã™ã‚‹éƒ½é“åºœçœŒã‚’é¸æŠã‚»ãƒ¨
      </div>
      <div id="country-list" class="country-grid"></div>
    </div>

    <div id="select-box"></div>

    <!-- ãƒˆãƒƒãƒ—ãƒãƒ¼ -->
    <div id="topbar">
      <div class="flag" onclick="UI.toggleSidebar()" id="player-flag">ğŸ³ï¸</div>
      <div class="res-grp">
        <div class="res" title="æ”¿æ²»åŠ›">
          <span class="icon" style="background: #8d6e63"></span
          ><span class="val" id="res-pp">0</span>
        </div>
        <div class="res" title="å®‰å®šåº¦">
          <span class="icon" style="background: #fbc02d"></span
          ><span class="val" id="res-st">0%</span>
        </div>
        <div class="res" title="æˆ¦äº‰å”åŠ›åº¦">
          <span class="icon" style="background: #d32f2f"></span
          ><span class="val" id="res-ws">0%</span>
        </div>
      </div>
      <div class="res-grp">
        <div class="res" title="çœŒæ°‘(äººçš„è³‡æº)">
          <span class="icon" style="background: #5d4037"></span
          ><span class="val" id="res-man">0</span>
        </div>
        <div class="res" title="è£…å‚™">
          <span class="icon" style="background: #ff9800"></span
          ><span class="val" id="res-eq">0</span>
        </div>
        <div class="res" title="é™¸è»çµŒé¨“å€¤">
          <span class="icon" style="background: #66bb6a"></span
          ><span class="val" id="res-xp">0</span>
        </div>
      </div>
      <div class="date-box">
        <button class="spd-btn" onclick="Game.setSpeed(0)">||</button>
        <button class="spd-btn" onclick="Game.setSpeed(1)">1</button>
        <button class="spd-btn" onclick="Game.setSpeed(3)">3</button>
        <button class="spd-btn" onclick="Game.setSpeed(5)">5</button>
        <div
          id="game-date"
          style="font-weight: bold; margin-left: 8px; font-size: 14px"
        >
          Day 1
        </div>
      </div>
    </div>

    <!-- ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ -->
    <div id="game-layout">
      <!-- ã‚µã‚¤ãƒ‰ãƒãƒ¼ -->
      <div id="sidebar">
        <div class="tabs">
          <div class="tab active" onclick="UI.tab('main')">çœŒæ”¿</div>
          <div class="tab" onclick="UI.tab('army')">è»äº‹</div>
          <div class="tab" onclick="UI.tab('diplo')">å¤–äº¤</div>
        </div>

        <!-- å›½å®¶ã‚¿ãƒ– -->
        <div id="v-main" class="view active">
          <div class="sb-profile">
            <div
              class="sb-portrait-wrapper"
              id="sb-portrait"
              style="font-size: 30px; margin-right: 10px"
            >
              ?
            </div>
            <div>
              <div style="font-weight: bold; font-size: 16px" id="sb-name">
                Country
              </div>
              <div style="font-size: 12px; color: #aaa" id="sb-ideology">
                ä¸å…š: çœŒæ°‘ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ
              </div>
            </div>
          </div>
          <button class="btn focus-btn-custom" onclick="UI.openFocusTree()">
            <span class="focus-caption">çœŒæ”¿æ–¹é‡</span><br />
            <span id="sb-focus-curr" class="focus-name">é¸æŠã—ã¦ãã ã•ã„</span>
            <div class="focus-bar-bg">
              <div id="sb-focus-bar" class="focus-bar-progress"></div>
            </div>
          </button>
          <button
            class="btn btn-green"
            style="margin-top: 10px"
            onclick="Game.buildFactory()"
          >
            <span style="font-size: 16px">çœŒå–¶å·¥å ´å»ºè¨­</span><br />
            <span style="font-size: 11px; font-weight: normal"
              >æ”¿æ²»åŠ›:50, å»ºè¨­æœŸé–“:10æ—¥</span
            >
          </button>
          <div style="margin-top: 20px; font-size: 13px; color: #aaa">
            <div>
              å…¨å›½ç·Šå¼µåº¦:
              <span
                id="val-wt"
                style="
                  color: var(--danger);
                  font-weight: bold;
                  text-shadow: 0 0 5px red;
                "
                >0%</span
              >
            </div>
            <div>å·¥å ´æ•°: <span id="res-fac" style="color: #fff">0</span></div>
          </div>
        </div>

        <!-- è»äº‹ã‚¿ãƒ– -->
        <div id="v-army" class="view">
          <div
            style="
              background: #222;
              padding: 10px;
              border-radius: 5px;
              margin-bottom: 15px;
              border: 1px solid #333;
            "
          >
            <div
              style="
                font-size: 12px;
                color: #aaa;
                margin-bottom: 8px;
                display: flex;
                justify-content: space-between;
              "
            >
              <span>ç¾åœ¨ã®å¸«å›£ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ</span>
              <span
                style="color: var(--hl); cursor: pointer"
                onclick="UI.openDesigner()"
                >[ç·¨é›†]</span
              >
            </div>
            <div
              id="army-tmpl-stats"
              style="
                font-size: 11px;
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 5px;
                color: #ddd;
              "
            ></div>
          </div>
          <button class="btn btn-green" onclick="Game.recruit()">
            <span style="font-size: 16px">çœŒå…µå¾´å‹Ÿ</span><br />
            <span style="font-size: 11px; font-weight: normal" id="recruit-cost"
              >äººçš„:1000 è£…å‚™:100</span
            >
          </button>
          <div
            style="
              margin-top: 20px;
              padding-top: 10px;
              border-top: 1px solid #333;
            "
          >
            <div class="focus-caption">
              é¸æŠä¸­ã®å¸«å›£:
              <span id="sel-count" style="color: var(--hl); font-weight: bold"
                >0</span
              >
            </div>
            <div class="focus-caption">
              ç·å¸«å›£æ•°: <span id="army-count">0</span>
            </div>
            <div class="focus-caption">
              æœ€å¤§å¸«å›£æ•°(1çœŒ): <span id="army-cap">50</span>
            </div>
          </div>
        </div>

        <!-- å¤–äº¤ã‚¿ãƒ– -->
        <div id="v-diplo" class="view">
          <div
            id="diplo-msg"
            style="
              padding: 40px 20px;
              text-align: center;
              color: #666;
              border: 2px dashed #333;
              border-radius: 10px;
            "
          >
            åœ°å›³ä¸Šã®çœŒã‚’<br />ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„
          </div>
          <div id="diplo-content" style="display: none">
            <h2 id="dp-name" style="color: var(--warn); margin: 0 0 10px 0">
              Country
            </h2>
            <div
              style="
                margin-bottom: 20px;
                padding: 10px;
                background: #222;
                border-radius: 5px;
              "
            >
              <div class="focus-caption">
                é™£å–¶: <span id="dp-faction" style="color: #fff">ãªã—</span>
              </div>
            </div>
            <div
              id="dp-war-status"
              style="
                color: var(--danger);
                font-weight: bold;
                margin-bottom: 15px;
                display: none;
                text-align: center;
                border: 1px solid var(--danger);
                padding: 5px;
                background: #200;
              "
            >
              âš¡ æŠ—äº‰çŠ¶æ…‹ âš¡
            </div>
            <button
              class="btn btn-red"
              id="btn-declare-war"
              onclick="Game.justifyWar()"
            >
              å®£æˆ¦å¸ƒå‘Šã®æ­£å½“åŒ–
            </button>
          </div>
        </div>
      </div>

      <!-- ãƒãƒƒãƒ— -->
      <div id="map-wrap">
        <div
          id="btn-plan-mode"
          onclick="Input.togglePlanMode()"
          title="ä½œæˆ¦ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿"
        >
          ğŸ–Šï¸
        </div>
        <div id="news-feed"></div>
      </div>
    </div>

    <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: å›½å®¶æ–¹é‡ -->
    <div id="focus-modal" class="modal">
      <div class="modal-win">
        <div class="modal-head">
          <span style="font-size: 18px; font-weight: bold; color: #ddd"
            >çœŒæ”¿æ–¹é‡ãƒ„ãƒªãƒ¼ (ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç§»å‹•)</span
          >
          <button class="close-btn-lg" onclick="UI.closeFocusTree()">Ã—</button>
        </div>
        <div class="modal-body" id="focus-scroll-area">
          <div id="focus-canvas">
            <svg id="focus-lines" class="focus-lines-svg"></svg>
            <div id="focus-nodes"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: å¸«å›£è¨­è¨ˆï¼ˆã‚¹ãƒãƒ›å¯¾å¿œä¿®æ­£ç‰ˆï¼‰ -->
    <div id="design-modal" class="modal">
      <div class="modal-win">
        <div class="modal-head">
          <div style="display: flex; align-items: center; gap: 10px">
            <span style="font-size: 16px; font-weight: bold">å¸«å›£ç·¨æˆ</span>
            <span
              style="
                font-size: 12px;
                background: #444;
                padding: 2px 8px;
                border-radius: 10px;
              "
              >â˜… <span id="ds-xp">0</span> XP</span
            >
          </div>
          <button class="close-btn-lg" onclick="UI.closeDesigner()">Ã—</button>
        </div>
        <div class="ds-layout">
          <div class="ds-panel">
            <div
              style="
                font-size: 12px;
                color: #888;
                text-align: center;
                margin-bottom: 5px;
                font-weight: bold;
              "
            >
              æˆ¦é—˜å¤§éšŠ
            </div>
            <div id="opt-battalions"></div>
            <div
              style="
                font-size: 12px;
                color: #888;
                text-align: center;
                margin: 20px 0 5px 0;
                font-weight: bold;
              "
            >
              æ”¯æ´ä¸­éšŠ
            </div>
            <div id="opt-support"></div>
          </div>
          <div class="ds-main">
            <div style="width: 100%; max-width: 500px">
              <div class="ds-grid">
                <div
                  style="
                    grid-column: 1/-1;
                    font-size: 12px;
                    color: #888;
                    text-align: center;
                    margin-bottom: 5px;
                  "
                >
                  ä¸»åŠ›å¤§éšŠ (æœ€å¤§6)
                </div>
                <div id="grid-bat" style="display: contents"></div>
              </div>
              <div
                class="ds-grid"
                style="grid-template-columns: repeat(3, 1fr)"
              >
                <div
                  style="
                    grid-column: 1/-1;
                    font-size: 12px;
                    color: #888;
                    text-align: center;
                    margin-bottom: 5px;
                  "
                >
                  æ”¯æ´ä¸­éšŠ (æœ€å¤§3)
                </div>
                <div id="grid-sup" style="display: contents"></div>
              </div>
            </div>
            <div
              id="ds-stats-box"
              style="
                width: 100%;
                max-width: 500px;
                background: #222;
                padding: 10px;
                border-radius: 5px;
                margin-top: 10px;
                border: 1px solid #333;
                font-size: 13px;
              "
            >
              <div
                style="
                  font-size: 12px;
                  color: #aaa;
                  margin-bottom: 5px;
                  border-bottom: 1px solid #444;
                "
              >
                äºˆæ¸¬ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
              </div>
              <div
                style="
                  display: grid;
                  grid-template-columns: 1fr 1fr;
                  gap: 4px;
                  width: 100%;
                "
              >
                <div style="display: flex; justify-content: space-between">
                  <span>å¯¾äººæ”»æ’ƒ</span
                  ><span
                    style="font-weight: bold; color: var(--warn)"
                    id="ds-atk-s"
                    >0</span
                  >
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span>å¯¾ç”²æ”»æ’ƒ</span
                  ><span
                    style="font-weight: bold; color: var(--danger)"
                    id="ds-atk-h"
                    >0</span
                  >
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span>é˜²å¾¡</span
                  ><span style="font-weight: bold; color: #42a5f5" id="ds-def"
                    >0</span
                  >
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span>çªç ´</span
                  ><span style="font-weight: bold; color: #ce93d8" id="ds-brk"
                    >0</span
                  >
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span>è£…ç”²</span
                  ><span style="font-weight: bold; color: #bdbdbd" id="ds-arm"
                    >0</span
                  >
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span>ã‚³ã‚¹ãƒˆ</span
                  ><span style="font-weight: bold; color: #fff" id="ds-cost"
                    >0</span
                  >
                </div>
              </div>
            </div>
            <button
              class="btn btn-green"
              style="margin-top: 10px; width: 100%"
              onclick="Designer.save()"
            >
              ä¿å­˜ (ã‚³ã‚¹ãƒˆ: 10 XP)
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const $ = (id) => document.getElementById(id);
      const $c = (t, c) => {
        const e = document.createElement(t);
        if (c) e.className = c;
        return e;
      };
      const nFmt = (n) =>
        n >= 1e6
          ? (n / 1e6).toFixed(2) + "M"
          : n >= 1e3
          ? (n / 1e3).toFixed(1) + "K"
          : n;

      let colorHue = Math.random();
      const nextColor = () => {
        colorHue = (colorHue + 0.618033988749895) % 1;
        return `hsl(${Math.floor(colorHue * 360)}, 65%, 45%)`;
      };

      // ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
      const SuperEvent = {
        overlay: $("super-event-overlay"),
        title: $("se-title"),
        quote: $("se-quote"),
        author: $("se-author"),
        btnText: $("se-btn-text"),
        imgBox: $("se-img-box"),
        icon: $("se-icon"),
        history: [],
        trigger: function (title, quote, author, iconStr, color, btnText) {
          if (!this.overlay) return;
          if (this.history.includes(title)) return;

          this.title.innerText = title;
          this.quote.innerHTML = quote.replace(/\n/g, "<br>");
          this.author.innerText = "- " + author;
          this.icon.innerText = iconStr || "âš ï¸";
          this.btnText.innerText = btnText || "æˆ‘ã€…ãƒ‹é¸æŠè‚¢ãƒç„¡ã‚¤ã€‚";
          this.imgBox.style.background = color || "#333";
          this.overlay.style.display = "flex";

          this.history.push(title);
        },
        close: function () {
          if (this.overlay) this.overlay.style.display = "none";
        },
      };

      const DB = {
        UnitTypes: {
          inf: {
            name: "æ™®é€šç§‘",
            icon: "ğŸª–",
            type: "bat",
            sa: 12,
            ha: 2,
            def: 25,
            brk: 5,
            arm: 0,
            prc: 5,
            org: 60,
            spd: 4.0,
            cost: 300,
          },
          art: {
            name: "ç‰¹ç§‘",
            icon: "ğŸ’¥",
            type: "bat",
            sa: 45,
            ha: 5,
            def: 5,
            brk: 5,
            arm: 0,
            prc: 5,
            org: 10,
            spd: 3.5,
            cost: 700,
          },
          tank: {
            name: "æ©Ÿç”²ç§‘",
            icon: "ğŸšœ",
            type: "bat",
            sa: 30,
            ha: 40,
            def: 15,
            brk: 55,
            arm: 50,
            prc: 45,
            org: 30,
            spd: 8.0,
            cost: 3000,
          },
          mot: {
            name: "å³å¿œæ©Ÿå‹•",
            icon: "ğŸšš",
            type: "bat",
            sa: 15,
            ha: 3,
            def: 20,
            brk: 20,
            arm: 5,
            prc: 8,
            org: 55,
            spd: 12.0,
            cost: 1000,
          },
          mech: {
            name: "æ©Ÿæ¢°åŒ–",
            icon: "ğŸš™",
            type: "bat",
            sa: 22,
            ha: 15,
            def: 35,
            brk: 30,
            arm: 25,
            prc: 20,
            org: 50,
            spd: 10.0,
            cost: 1800,
          },
          bike: {
            name: "è‡ªè»¢è»Š",
            icon: "ğŸš²",
            type: "bat",
            sa: 14,
            ha: 2,
            def: 20,
            brk: 12,
            arm: 0,
            prc: 5,
            org: 55,
            spd: 9.0,
            cost: 400,
          },
          eng: {
            name: "æ–½è¨­ç§‘",
            icon: "ğŸ› ï¸",
            type: "sup",
            sa: 5,
            ha: 2,
            def: 25,
            brk: 5,
            arm: 0,
            prc: 5,
            org: 20,
            spd: 0,
            cost: 500,
          },
          rec: {
            name: "åµå¯Ÿ",
            icon: "ğŸ”­",
            type: "sup",
            sa: 4,
            ha: 1,
            def: 5,
            brk: 5,
            arm: 0,
            prc: 0,
            org: 10,
            spd: 1.1,
            cost: 400,
          },
          sup_art: {
            name: "æ”¯æ´ç«ç ²",
            icon: "ğŸ§¨",
            type: "sup",
            sa: 25,
            ha: 2,
            def: 5,
            brk: 5,
            arm: 0,
            prc: 5,
            org: 0,
            spd: 0,
            cost: 600,
          },
        },
        AITemplates: {
          basic_inf: { bat: ["inf", "inf", "inf", "inf"], sup: ["eng"] },
          strong_inf: {
            bat: ["inf", "inf", "inf", "art"],
            sup: ["eng", "sup_art"],
          },
          bike_div: { bat: ["bike", "bike", "bike", "bike"], sup: ["rec"] },
          mot_div: {
            bat: ["mot", "mot", "mot", "tank"],
            sup: ["eng", "sup_art"],
          },
          mech_div: {
            bat: ["mech", "mech", "mech", "tank"],
            sup: ["eng", "rec"],
          },
          tank_div: {
            bat: ["tank", "tank", "mot", "mot"],
            sup: ["eng", "sup_art"],
          },
          elite_tank: {
            bat: ["tank", "tank", "tank", "mech", "mech"],
            sup: ["eng", "rec", "sup_art"],
          },
        },
        FocusTree: { GENERIC: [] },
        Terrain: {
          sea: { name: "ç€¬æˆ¸å†…æµ·/æµ·", color: "#050a10", moveCost: 5 },
          plains: { name: "å¹³åœ°", color: "#3e4e38", moveCost: 1 },
        },
        Tactics: {
          BLITZ: { id: "BLITZ", name: "é›»æ’ƒçš„ä¾µæ”»", priority: "city" },
          PUSH: { id: "PUSH", name: "æ­£é¢çªç ´", priority: "front" },
          HOLD: { id: "HOLD", name: "å°‚å®ˆé˜²è¡›", priority: "defend" },
          ENCIRCLE: { id: "ENCIRCLE", name: "åŒ…å›²æ®²æ»…", priority: "gap" },
          REGROUP: { id: "REGROUP", name: "æˆ¦ç•¥çš„è»¢é€²", priority: "retreat" },
        },
      };

      const FT = [];
      const addF = (id, x, y, t, d, cost, req, eff, mut, cond) =>
        FT.push({ id, x, y, t, d, cost, req, eff, mut, cond });
      addF(
        "pol_start",
        1400,
        50,
        "çœŒç‹¬ç«‹å®£è¨€",
        "æ”¿åºœã‹ã‚‰ã®åˆ†é›¢ç‹¬ç«‹ã‚’å®£è¨€ã™ã‚‹ã€‚",
        70,
        [],
        (c) => {
          c.pp += 100;
          c.st += 10;
        }
      );
      addF(
        "pol_council",
        1400,
        200,
        "çœŒè­°ä¼šã®æŒæ¡",
        "åå¯¾æ´¾ã‚’æ’é™¤ã—ã€è­°ä¼šã‚’çµ±ä¸€ã™ã‚‹ã€‚",
        70,
        ["pol_start"],
        (c) => (c.st += 5)
      );

      // è¦‡é“ãƒ«ãƒ¼ãƒˆ (Fascist/Expansionist)
      addF(
        "pol_auth",
        1250,
        350,
        "æ–°ãƒ»å¹•åºœé–‹é—¢",
        "æˆ‘ã‚‰ãŒçœŒã“ããŒæ—¥æœ¬ã®æ”¯é…è€…ã¨ãªã‚‹ã€‚\næ”¿æ²»åŠ›+100, æ’ä»–: åœ°æ–¹è‡ªæ²»",
        100,
        ["pol_council"],
        (c) => {
          c.pp += 100;
          c.ws += 20;
          c.ideology = "æ–°å¹•åºœ";
        },
        ["pol_demo"]
      );
      addF(
        "pol_auth_1",
        1250,
        500,
        "è¿‘éš£çœŒã¸ã®å¨åœ§",
        "ã€Œåˆä½µã€ã‹ã€Œæ­»ã€ã‹ã€‚\næ”¿æ²»åŠ›+150",
        120,
        ["pol_auth"],
        (c) => (c.pp += 150)
      );
      addF(
        "pol_auth_2",
        1250,
        650,
        "çœŒæ°‘ç·å‹•å“¡æ³•",
        "äººçš„è³‡æº+10000",
        120,
        ["pol_auth_1"],
        (c) => (c.mp += 10000)
      );
      addF(
        "pol_auth_3",
        1250,
        800,
        "å¤©ä¸‹å¸ƒæ­¦",
        "æ­£å½“åŒ–æ™‚é–“ã®çŸ­ç¸®",
        140,
        ["pol_auth_2"],
        (c) => {
          if (c.tag === Game.player) UI.notify("å¤–äº¤çš„åœ§åŠ›ã‚’å¼·åŒ–ã—ã¾ã—ãŸ");
        }
      );
      addF(
        "pol_auth_end",
        1250,
        1000,
        "å¤§æ”¿å¥‰é‚„ã®è¦æ±‚",
        "SEç™ºç”Ÿ: ä»¤å’Œã®é–¢ãƒ¶åŸ",
        200,
        ["pol_auth_3"],
        (c) => {
          SuperEvent.trigger(
            "ä»¤å’Œã®é–¢ãƒ¶åŸ",
            "ã‚‚ã¯ã‚„å¯¾è©±ã®æ™‚é–“ã¯çµ‚ã‚ã£ãŸã€‚\nå…¨è»ã€ä¸Šæ´›ã›ã‚ˆã€‚",
            "ç·ç£åºœ",
            "ğŸŒ",
            "#500",
            "é€²ã‚ï¼"
          );
          c.ws = 100;
          c.pp += 500;
        }
      );

      // ç‹é“ãƒ«ãƒ¼ãƒˆ (Democratic/Alliance)
      addF(
        "pol_demo",
        1550,
        350,
        "åœ°æ–¹è‡ªæ²»æ†²ç« ",
        "å¹³å’Œã¨ç¹æ „ã‚’ã€‚\nå®‰å®š+10%, æ’ä»–: è¦‡é“",
        100,
        ["pol_council"],
        (c) => {
          c.st += 10;
          c.pp += 50;
          c.ideology = "ç«‹æ†²è‡ªæ²»";
        },
        ["pol_auth"]
      );
      addF(
        "pol_demo_1",
        1550,
        500,
        "åœ°åŸŸåŒ…æ‹¬ã‚±ã‚¢ã‚·ã‚¹ãƒ†ãƒ ",
        "å®‰å®šåº¦+10%",
        120,
        ["pol_demo"],
        (c) => (c.st += 10)
      );
      addF(
        "pol_demo_2",
        1550,
        650,
        "åºƒåŸŸé˜²ç½å”å®š",
        "å·¥å ´+2",
        140,
        ["pol_demo_1"],
        (c) => {
          c.fac += 2;
          if (c.tag === Game.player) UI.notify("éš£çœŒã¨ã®å”åŠ›ã«ã‚ˆã‚Šå·¥å ´å»ºè¨­");
        }
      );
      addF(
        "pol_demo_3",
        1550,
        800,
        "é“å·åˆ¶ã®å°å…¥",
        "å®‰å®šåº¦+20%",
        140,
        ["pol_demo_2"],
        (c) => {
          c.st += 20;
          if (c.tag === Game.player)
            UI.notify("æ–°æ™‚ä»£ã®çµ±æ²»æ©Ÿæ§‹ã‚’ç™ºè¡¨ã—ã¾ã—ãŸã€‚");
        }
      );

      // ç”£æ¥­ãƒ«ãƒ¼ãƒˆ
      addF(
        "ind_start",
        900,
        200,
        "åœ°æ–¹å‰µç”Ÿ(ç‰©ç†)",
        "å·¥å ´+1",
        100,
        ["pol_start"],
        (c) => (c.fac += 1)
      );
      addF(
        "ind_heavy_1",
        800,
        350,
        "åœ°å ´ç”£æ¥­ã®è»éœ€åŒ–",
        "å·¥å ´+1",
        100,
        ["ind_start"],
        (c) => (c.fac += 1)
      );
      addF(
        "ind_heavy_2",
        800,
        500,
        "ã‚³ãƒ³ãƒ“ãƒŠãƒ¼ãƒˆè¦å¡åŒ–",
        "å·¥å ´+2",
        150,
        ["ind_heavy_1"],
        (c) => (c.fac += 2)
      );
      addF(
        "ind_heavy_3",
        800,
        650,
        "ãµã‚‹ã•ã¨ç´ç¨è»äº‹è»¢ç”¨",
        "è£…å‚™+5000",
        120,
        ["ind_heavy_2"],
        (c) => (c.eq += 5000)
      );
      addF(
        "ind_nuc",
        700,
        850,
        "æ¥µç§˜ç ”ç©¶æ‰€(ç†ç ”)",
        "ç ”ç©¶å®Œäº†",
        300,
        ["ind_heavy_3"],
        (c) => {
          if (c.tag === Game.player) UI.notify("ã‚ãŒçœŒã®ç ”ç©¶åŠ›ãŒä¸–ç•Œä¸€ã‚£ã‚£ï¼");
        }
      );

      addF(
        "ind_tech_1",
        1000,
        350,
        "ITç‰¹åŒº",
        "å»ºè¨­é€Ÿåº¦+10%",
        100,
        ["ind_start"],
        (c) =>
          (c.factoryBuildSpeedBonus = (c.factoryBuildSpeedBonus || 0) + 0.1)
      );
      addF(
        "ind_tech_2",
        1000,
        500,
        "ã‚·ãƒªã‚³ãƒ³ã‚¢ã‚¤ãƒ©ãƒ³ãƒ‰",
        "å·¥å ´+1, å»ºè¨­+10%",
        150,
        ["ind_tech_1"],
        (c) => {
          c.fac += 1;
          c.factoryBuildSpeedBonus += 0.1;
        }
      );
      addF(
        "ind_tech_3",
        1000,
        650,
        "ç„¡äººå·¥å ´",
        "å·¥å ´+3",
        200,
        ["ind_tech_2"],
        (c) => (c.fac += 3)
      );
      addF(
        "ind_cap",
        1000,
        850,
        "çœŒéƒ½é˜²è¡›è¦å¡",
        "å®‰å®š+15%, å·¥å ´+2",
        200,
        ["ind_tech_3"],
        (c) => {
          c.st += 15;
          c.fac += 2;
        }
      );

      // è»äº‹ãƒ«ãƒ¼ãƒˆ
      addF(
        "mil_start",
        1900,
        200,
        "çœŒè­¦ã®è»éšŠåŒ–",
        "XP+20",
        80,
        ["pol_start"],
        (c) => (c.xp += 20)
      );
      addF(
        "mil_mob_1",
        1800,
        350,
        "æ©Ÿå‹•éšŠãƒ‰ã‚¯ãƒˆãƒªãƒ³",
        "çªç ´+10%",
        120,
        ["mil_start"],
        (c) => {
          if (c.tag === Game.player) UI.notify("æ©Ÿå‹•æˆ¦ãƒ‰ã‚¯ãƒˆãƒªãƒ³æ¡ç”¨");
        }
      );
      addF(
        "mil_mob_2",
        1800,
        500,
        "å¿«é€Ÿéƒ¨éšŠç·¨æˆ",
        "è£…å‚™+500, XP+50",
        150,
        ["mil_mob_1"],
        (c) => {
          c.eq += 500;
          c.xp += 50;
        }
      );
      addF(
        "mil_mob_3",
        1800,
        650,
        "é›»æ’ƒçš„çœŒå¢ƒçªç ´",
        "å…¨è»é€Ÿåº¦+10%",
        150,
        ["mil_mob_2"],
        (c) => {
          if (c.tag === Game.player) UI.notify("é›»æ’ƒæˆ¦ç†è«–ã®ç ”ç©¶å®Œäº†");
        }
      );

      addF(
        "mil_def_1",
        2000,
        350,
        "æŒä¹…æˆ¦ãƒ‰ã‚¯ãƒˆãƒªãƒ³",
        "é˜²å¾¡+10%",
        120,
        ["mil_start"],
        (c) => (c.territoryDefBonus = (c.territoryDefBonus || 0) + 0.1)
      );
      addF(
        "mil_def_2",
        2000,
        500,
        "çµ¶å¯¾é˜²è¡›ç·š",
        "å®‰å®š+5%",
        150,
        ["mil_def_1"],
        (c) => (c.st += 5)
      );
      addF(
        "mil_def_3",
        2000,
        650,
        "çœŒæ°‘ç·ç‰ç •",
        "äººçš„+30000",
        150,
        ["mil_def_2"],
        (c) => (c.mp += 30000)
      );

      addF(
        "fin_unify",
        1400,
        1200,
        "æ—¥æœ¬åˆ—å³¶çµ±ä¸€",
        "å…¨æ•µå›½ã‚’ä½µåˆã™ã‚‹å¿…è¦ã‚ã‚Š",
        365,
        ["pol_auth_end", "ind_cap"],
        (c) => {
          c.pp += 1000;
          c.st = 100;
          c.ws = 100;
          c.mp += 50000;
          c.fac += 10;
          SuperEvent.trigger(
            "æ–°æ—¥æœ¬å¸å›½æ¨¹ç«‹",
            "æˆ¦ä¹±ã®ä¸–ã¯çµ‚ã‚ã‚Šã€æ–°ãŸãªå¤ªé™½ãŒæ˜‡ã‚‹ã€‚\næ°¸é ãªã‚‹å¹³å’Œã®å§‹ã¾ã‚Šã ã€‚",
            "å¤§ç·çµ±",
            "ğŸ—¾",
            "#b71c1c",
            "ä¸‡æ­³ï¼ä¸‡æ­³ï¼ä¸‡æ­³ï¼"
          );
        },
        null,
        (c) => Game.getAliveCountryCount() === 1
      );

      DB.FocusTree.GENERIC = FT;
      const CapitalCoords = {
        P1: { lat: 43.064359, lon: 141.347449 }, // åŒ—æµ·é“
        P2: { lat: 40.824294, lon: 140.740054 }, // é’æ£®
        P3: { lat: 39.70353, lon: 141.152667 }, // å²©æ‰‹
        P4: { lat: 38.268737, lon: 140.872183 }, // å®®åŸ
        P5: { lat: 39.718175, lon: 140.103356 }, // ç§‹ç”°
        P6: { lat: 38.240127, lon: 140.362533 }, // å±±å½¢
        P7: { lat: 37.750146, lon: 140.466754 }, // ç¦å³¶
        P8: { lat: 36.341817, lon: 140.446796 }, // èŒ¨åŸ
        P9: { lat: 36.56575, lon: 139.883526 }, // æ ƒæœ¨
        P10: { lat: 36.391205, lon: 139.060917 }, // ç¾¤é¦¬
        P11: { lat: 35.857771, lon: 139.647804 }, // åŸ¼ç‰
        P12: { lat: 35.604563, lon: 140.123179 }, // åƒè‘‰
        P13: { lat: 35.689185, lon: 139.691648 }, // æ±äº¬
        P14: { lat: 35.447505, lon: 139.642347 }, // ç¥å¥ˆå·
        P15: { lat: 37.901699, lon: 139.022728 }, // æ–°æ½Ÿ
        P16: { lat: 36.695274, lon: 137.211302 }, // å¯Œå±±
        P17: { lat: 36.594729, lon: 136.62555 }, // çŸ³å·
        P18: { lat: 36.06522, lon: 136.221641 }, // ç¦äº•
        P19: { lat: 35.663927, lon: 138.568115 }, // å±±æ¢¨
        P20: { lat: 36.651304, lon: 138.181061 }, // é•·é‡
        P21: { lat: 35.39123, lon: 136.722291 }, // å²é˜œ
        P22: { lat: 34.975556, lon: 138.382778 }, // é™å²¡
        P23: { lat: 35.181474, lon: 136.906403 }, // æ„›çŸ¥
        P24: { lat: 34.730283, lon: 136.508589 }, // ä¸‰é‡
        P25: { lat: 35.004528, lon: 135.868634 }, // æ»‹è³€
        P26: { lat: 35.021071, lon: 135.755607 }, // äº¬éƒ½
        P27: { lat: 34.686316, lon: 135.519711 }, // å¤§é˜ª
        P28: { lat: 34.691269, lon: 135.183051 }, // å…µåº«
        P29: { lat: 34.685318, lon: 135.832743 }, // å¥ˆè‰¯
        P30: { lat: 34.226047, lon: 135.167506 }, // å’Œæ­Œå±±
        P31: { lat: 35.503623, lon: 134.238291 }, // é³¥å–
        P32: { lat: 35.472295, lon: 133.050499 }, // å³¶æ ¹
        P33: { lat: 34.661771, lon: 133.935 }, // å²¡å±±
        P34: { lat: 34.39656, lon: 132.459622 }, // åºƒå³¶
        P35: { lat: 34.185193, lon: 131.470495 }, // å±±å£
        P36: { lat: 34.065833, lon: 134.559444 }, // å¾³å³¶
        P37: { lat: 34.340149, lon: 134.043444 }, // é¦™å·
        P38: { lat: 33.841639, lon: 132.765 }, // æ„›åª›
        P39: { lat: 33.559706, lon: 133.531084 }, // é«˜çŸ¥
        P40: { lat: 33.606785, lon: 130.418315 }, // ç¦å²¡
        P41: { lat: 33.249445, lon: 130.29878 }, // ä½è³€
        P42: { lat: 32.74499, lon: 129.873536 }, // é•·å´
        P43: { lat: 32.789825, lon: 130.741667 }, // ç†Šæœ¬
        P44: { lat: 33.2382, lon: 131.612579 }, // å¤§åˆ†
        P45: { lat: 31.911077, lon: 131.423877 }, // å®®å´
        P46: { lat: 31.596553, lon: 130.557115 }, // é¹¿å…å³¶
        P47: { lat: 26.212401, lon: 127.680931 }, // æ²–ç¸„
      };

      const MapSys = { hexes: [] };

      const UI = {
        _lastValues: {}, // å‰å›ã®å€¤ã‚’ä¿å­˜ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        init: function () {
          this.update();
          // åˆæœŸå€¤ã§_lastValuesã‚’åŸ‹ã‚ã‚‹
          const p = Game.countries[Game.player];
          if (p) {
            this._lastValues.pp = ~~p.pp;
            this._lastValues.st = p.st;
            this._lastValues.ws = p.ws;
            this._lastValues.mp = nFmt(p.mp);
            this._lastValues.fac = p.fac;
            this._lastValues.eq = nFmt(p.eq);
            this._lastValues.xp = ~~p.xp;
            this._lastValues.tension = Game.tension;
            this._lastValues.armyCount = Game.units.filter(
              (u) => u.tag === Game.player
            ).length;
            this._lastValues.focusText = ""; // Focus text is dynamic
            this._lastValues.focusBarWidth = "0%";
            this._lastValues.tmplStats = ""; // Army template stats
            this._lastValues.recruitCost = "";
            this._lastValues.gameDate = "Day " + Game.day;
            this._lastValues.playerFlag = p.flag;
          }
        },
        update: function () {
          const p = Game.countries[Game.player];
          if (!p) return;

          // é »ç¹ã«æ›´æ–°ã™ã‚‹å¿…è¦ã®ã‚ã‚‹è¦ç´ ã®ã¿
          const now = Date.now();
          if (!this.lastUpdateTime || now - this.lastUpdateTime > 500) {
            // 0.5ç§’é–“éš”
            this.lastUpdateTime = now;

            // ãƒªã‚½ãƒ¼ã‚¹è¡¨ç¤º
            $("res-pp").innerText = ~~p.pp;
            $("res-st").innerText = p.st + "%";
            $("res-ws").innerText = p.ws + "%";
            $("res-man").innerText = nFmt(p.mp);
            $("res-eq").innerText = nFmt(p.eq);
            $("res-xp").innerText = ~~p.xp;
            $("res-fac").innerText = p.fac;

            // æ—¥ä»˜
            $("game-date").innerText = "Day " + Game.day;
          }

          // å¸¸ã«æ›´æ–°ãŒå¿…è¦ãªè¦ç´ 
          const armyCount = Game.units.filter(
            (u) => u.tag === Game.player
          ).length;
          if (this._lastArmyCount !== armyCount) {
            $("army-count").innerText = armyCount;
            $("sel-count").innerText = Input.selUnits.length;
            this._lastArmyCount = armyCount;
          }

          // ç·Šå¼µåº¦
          const tension = Game.tension + "%";
          if (this._lastTension !== tension) {
            $("val-wt").innerText = tension;
            this._lastTension = tension;
          }

          // å›½å®¶æ–¹é‡/å·¥å ´å»ºè¨­ã®é€²æ—
          let focusText = "";
          let focusBarWidth = "0%";

          if (p.focus) {
            const pct = (p.focusProg / p.focus.cost) * 100;
            focusText = p.focus.t + " (" + ~~pct + "%)";
            focusBarWidth = Math.min(pct, 100) + "%";
          } else if (p.buildingFactory) {
            const pct =
              (p.buildingFactory.progress / p.buildingFactory.cost) * 100;
            focusText = `${p.buildingFactory.name}ä¸­... (${~~pct}%)`;
            focusBarWidth = Math.min(pct, 100) + "%";
          } else {
            focusText = "çœŒæ”¿æ–¹é‡ã‚’é¸æŠ";
          }

          if (this._lastFocusText !== focusText) {
            $("sb-focus-curr").innerText = focusText;
            this._lastFocusText = focusText;
          }

          if (this._lastFocusBarWidth !== focusBarWidth) {
            $("sb-focus-bar").style.width = focusBarWidth;
            this._lastFocusBarWidth = focusBarWidth;
          }
        },
        updateSidebar: function () {
          const t = Game.selected || Game.player;
          const c = Game.countries[t];
          if (!c) return;
          $("sb-name").innerText = c.name;
          $("sb-portrait").innerText = c.flag;
          $("sb-ideology").innerText = "æ”¿å…š: " + (c.ideology || "çœŒæ°‘å…š");
          const diploMsg = $("diplo-msg");
          const diploContent = $("diplo-content");
          if (Game.selected && Game.selected !== Game.player) {
            diploMsg.style.display = "none";
            diploContent.style.display = "block";
            $("dp-name").innerText = c.name;
            $("dp-faction").innerText = c.faction || "ãªã—";
            $("dp-war-status").style.display = Game.isWar(Game.player, t)
              ? "block"
              : "none";
            $("btn-declare-war").disabled = Game.isAlly(Game.player, t);
            if (!("ontouchstart" in window))
              $("sidebar").style.display = "flex";
            else $("sidebar").classList.add("show");
          } else {
            diploMsg.style.display = "block";
            diploContent.style.display = "none";
          }
        },
        toggleSidebar: function () {
          const s = $("sidebar");
          if (window.innerWidth <= 600) s.classList.toggle("show");
          else s.style.display = s.style.display === "none" ? "flex" : "none";
        },
        tab: function (id) {
          document
            .querySelectorAll(".tab")
            .forEach((e) => e.classList.remove("active"));
          document
            .querySelectorAll(".view")
            .forEach((e) => e.classList.remove("active"));
          event.target.classList.add("active");
          $(`v-${id}`).classList.add("active");
        },
        openFocusTree: function () {
          const p = Game.countries[Game.player];
          if (!p) return;
          const tree = DB.FocusTree.GENERIC;
          $("focus-nodes").innerHTML = "";
          $("focus-lines").innerHTML = "";
          tree.forEach((f) => {
            const el = $c("div", "focus-node");
            el.style.left = f.x + "px";
            el.style.top = f.y + "px";
            el.innerHTML = `<div class="focus-title">${f.t}</div><div class="focus-desc">${f.d}</div><div class="focus-cost">(${f.cost} days)</div>`;
            const comp = p.completedFocuses.includes(f.id);
            const excluded =
              f.mut && f.mut.some((m) => p.completedFocuses.includes(m));
            const avail =
              !comp &&
              !excluded &&
              f.req.every((r) => p.completedFocuses.includes(r));

            const condMet = !f.cond || f.cond(p);
            if (comp) el.classList.add("completed");
            else if (excluded) el.classList.add("exclusive-locked");
            else if (
              avail &&
              condMet &&
              !((p.focus && p.focus.id !== f.id) || p.buildingFactory)
            ) {
              el.classList.add("available");
              el.onclick = () => Game.startFocus(f.id);
            } else {
              el.classList.add("locked");
              if (avail && !condMet)
                el.innerHTML += `<div style="color:#d32f2f;font-weight:bold;margin-top:2px">æ¡ä»¶æœªé”æˆ</div>`;
            }
            if (p.focus && p.focus.id === f.id) el.classList.add("available");
            $("focus-nodes").appendChild(el);
            f.req.forEach((rid) => {
              const par = tree.find((x) => x.id === rid);
              if (par) {
                const l = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "line"
                );
                l.setAttribute("x1", par.x + 120);
                l.setAttribute("y1", par.y + 110);
                l.setAttribute("x2", f.x + 120);
                l.setAttribute("y2", f.y);
                l.setAttribute("stroke", comp ? "var(--hl)" : "#555");
                l.setAttribute("stroke-width", "2");
                $("focus-lines").appendChild(l);
              }
            });
            if (f.mut)
              f.mut.forEach((mid) => {
                const mNode = tree.find((x) => x.id === mid);
                if (mNode && mNode.x > f.x) {
                  const l2 = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "line"
                  );
                  l2.setAttribute("x1", f.x + 200);
                  l2.setAttribute("y1", f.y + 40);
                  l2.setAttribute("x2", mNode.x + 40);
                  l2.setAttribute("y2", mNode.y + 40);
                  l2.setAttribute("stroke", "#b71c1c");
                  l2.setAttribute("stroke-width", "2");
                  l2.setAttribute("stroke-dasharray", "5,5");
                  $("focus-lines").appendChild(l2);
                }
              });
          });
          const modal = $("focus-modal");
          modal.style.display = "flex";

          // ãƒ‰ãƒ©ãƒƒã‚°ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
          const area = $("focus-scroll-area");
          area.scrollLeft = 1000;
          area.scrollTop = 0;
          let isDown = false,
            sX,
            sY,
            sL,
            sT;
          const startDrag = (x, y) => {
            isDown = true;
            sX = x;
            sY = y;
            sL = area.scrollLeft;
            sT = area.scrollTop;
            area.style.cursor = "grabbing";
          };
          const doDrag = (x, y) => {
            if (!isDown) return;
            area.scrollLeft = sL - (x - sX);
            area.scrollTop = sT - (y - sY);
          };
          const endDrag = () => {
            isDown = false;
            area.style.cursor = "grab";
          };
          area.onmousedown = (e) => startDrag(e.pageX, e.pageY);
          area.onmousemove = (e) => {
            if (isDown) e.preventDefault();
            doDrag(e.pageX, e.pageY);
          };
          area.onmouseup = endDrag;
          area.onmouseleave = endDrag;

          area.addEventListener(
            "touchstart",
            (e) => {
              if (e.touches.length === 1)
                startDrag(e.touches[0].pageX, e.touches[0].pageY);
            },
            { passive: false }
          );
          area.addEventListener(
            "touchmove",
            (e) => {
              if (e.touches.length === 1) {
                e.preventDefault();
                doDrag(e.touches[0].pageX, e.touches[0].pageY);
              }
            },
            { passive: false }
          );
          area.addEventListener("touchend", endDrag);
        },
        openDesigner: function () {
          Designer.open();
        },
        closeDesigner: function () {
          $("design-modal").style.display = "none";
        },
        updateFocusModal: function () {
          if ($("focus-modal").style.display === "flex") this.openFocusTree();
        },
        closeFocusTree: function () {
          $("focus-modal").style.display = "none";
        },
        notify: function (m, t) {
          const d = $c("div", "news");
          d.innerHTML = `<div style="font-weight:bold;margin-bottom:3px;color:#aaa">Day ${Game.day}</div>${m}`;
          if (t === "war") {
            d.style.borderLeftColor = "var(--danger)";
            d.style.background = "rgba(60,10,10,.95)";
          } else if (t === "success") d.style.borderLeftColor = "var(--hl)";
          else if (t === "warn") {
            d.style.borderLeftColor = "var(--warn)";
            d.style.background = "rgba(60,60,10,.95)";
          }
          $("news-feed").prepend(d);
          setTimeout(() => d.remove(), 6000);
        },
        showStartScreen: function () {
          const list = $("country-list");
          list.innerHTML = "";
          const sortedTags = Object.keys(Game.countries)
            .filter((t) => t !== "_SEA")
            .sort((a, b) => Game.countries[b].fac - Game.countries[a].fac);
          sortedTags.forEach((tag) => {
            const c = Game.countries[tag];
            if (c.provs.length === 0) return;
            const d = $c("div", "country-card");
            d.innerHTML = `<div class="c-flag" style="color:${c.col}">${
              c.flag
            }</div><div class="c-name">${
              c.name
            }</div><div class="c-info">å·¥å ´:${c.fac} äººçš„:${nFmt(c.mp)}</div>`;
            d.onclick = () => Game.startGame(tag);
            list.appendChild(d);
          });
          $("start-screen").style.display = "flex";
          $("loading-overlay").style.display = "none";
        },
      };

      const Input = {
        isDown: false,
        isDrag: false,
        isShift: false,
        isRight: false,
        sx: 0,
        sy: 0,
        lastX: 0,
        lastY: 0,
        selUnits: [],
        battlePoints: [],
        battleLineEl: null,
        mapWrapEl: null,
        pinchDist: 0,
        pinchStartScale: 1,
        planMode: false,

        init: function () {
          this.mapWrapEl = $("map-wrap");
          window.addEventListener("keydown", (e) => {
            if (e.key === "Shift") this.isShift = true;
          });
          window.addEventListener("keyup", (e) => {
            if (e.key === "Shift") this.isShift = false;
          });

          // Mouse (PC)
          this.mapWrapEl.addEventListener("mousedown", (e) => {
            this.isDown = true;
            this.isDrag = false;
            this.sx = e.clientX;
            this.sy = e.clientY;
            this.lastX = e.clientX;
            this.lastY = e.clientY;
            this.isRight = e.button === 2;
            if (e.button === 1) e.preventDefault();

            const isDrawingAction =
              this.isRight || (this.planMode && e.button === 0);
            if (isDrawingAction && this.selUnits.length > 0) {
              this.battlePoints = [];
              this.startBattleLine({ clientX: e.clientX, clientY: e.clientY });
            }
            this.mapWrapEl.style.cursor = "grabbing";
          });
          window.addEventListener("mousemove", (e) => {
            if (!this.isDown) return;
            const dx = e.clientX - this.lastX,
              dy = e.clientY - this.lastY;
            if (
              Math.abs(e.clientX - this.sx) > 5 ||
              Math.abs(e.clientY - this.sy) > 5
            ) {
              this.isDrag = true;
              this.mapWrapEl.style.pointerEvents = "none";
            }

            const isDrawingAction =
              this.isRight || (this.planMode && e.buttons === 1);
            if (this.isShift && !this.isRight && !this.planMode) {
              this.updateBoxSelect(e);
            } else if (isDrawingAction && this.selUnits.length > 0) {
              this.updateBattleLine({ clientX: e.clientX, clientY: e.clientY });
            } else if (!isDrawingAction && this.isDrag) {
              Renderer.x += dx;
              Renderer.y += dy;
              Renderer.update();
            }
            this.lastX = e.clientX;
            this.lastY = e.clientY;
          });
          window.addEventListener("mouseup", (e) => {
            this.isDown = false;
            this.mapWrapEl.style.cursor = "grab";
            this.mapWrapEl.style.pointerEvents = "auto";
            $("select-box").style.display = "none";

            const isDrawingAction =
              this.isRight || (this.planMode && e.button === 0);
            if (this.isDrag) {
              if (this.isShift && !isDrawingAction) this.finishBoxSelect();
              else if (isDrawingAction && this.selUnits.length > 0)
                this.executeBattlePlan();
              return;
            }
            if (!this.planMode && !this.isRight) {
              const target = e.target;
              if (target.classList.contains("hex")) {
                const h = MapSys.hexes[target.dataset.id];
                if (h) this.onHexClick(e, h);
              } else if (target.closest(".unit-grp")) {
                const uEl = target.closest(".unit-grp");
                const u = Game.units.find((x) => x.el === uEl);
                if (u) {
                  e.stopPropagation();
                  this.onHexClick(e, u.hex);
                }
              }
            }
          });
          this.mapWrapEl.addEventListener(
            "wheel",
            (e) => {
              e.preventDefault();
              const f = e.deltaY > 0 ? 0.9 : 1.1;
              Renderer.s = Math.max(0.4, Math.min(5, Renderer.s * f));
              Renderer.update();
            },
            { passive: false }
          );

          // Touch Events (ã‚¹ãƒãƒ›å¯¾å¿œ)
          this.mapWrapEl.addEventListener(
            "touchstart",
            (e) => {
              if (e.touches.length === 1) {
                this.isDown = true;
                this.isDrag = false;
                this.sx = e.touches[0].clientX;
                this.sy = e.touches[0].clientY;
                this.lastX = this.sx;
                this.lastY = this.sy;
                this.isRight = false;

                if (this.planMode && this.selUnits.length > 0) {
                  this.battlePoints = [];
                  this.startBattleLine(e.touches[0]);
                }
              } else if (e.touches.length === 2) {
                this.isDown = false;
                this.pinchDist = Math.hypot(
                  e.touches[0].clientX - e.touches[1].clientX,
                  e.touches[0].clientY - e.touches[1].clientY
                );
                this.pinchStartScale = Renderer.s;
              }
            },
            { passive: false }
          );
          this.mapWrapEl.addEventListener(
            "touchmove",
            (e) => {
              if (this.planMode) e.preventDefault();
              if (e.touches.length === 1 && this.isDown) {
                const cx = e.touches[0].clientX;
                const cy = e.touches[0].clientY;

                if (this.planMode && this.selUnits.length > 0) {
                  this.updateBattleLine(e.touches[0]);
                } else {
                  const dx = cx - this.lastX;
                  const dy = cy - this.lastY;
                  if (
                    Math.abs(cx - this.sx) > 5 ||
                    Math.abs(cy - this.sy) > 5
                  ) {
                    this.isDrag = true;
                    this.mapWrapEl.style.pointerEvents = "none";
                  }
                  if (this.isDrag) {
                    Renderer.x += dx;
                    Renderer.y += dy;
                    Renderer.update();
                  }
                }
                this.lastX = cx;
                this.lastY = cy;
              } else if (e.touches.length === 2) {
                e.preventDefault();
                const dist = Math.hypot(
                  e.touches[0].clientX - e.touches[1].clientX,
                  e.touches[0].clientY - e.touches[1].clientY
                );
                const scale = (dist / this.pinchDist) * this.pinchStartScale;
                Renderer.s = Math.max(0.4, Math.min(5, scale));
                Renderer.update();
              }
            },
            { passive: false }
          );
          this.mapWrapEl.addEventListener("touchend", (e) => {
            this.isDown = false;
            this.mapWrapEl.style.pointerEvents = "auto";

            if (
              this.planMode &&
              this.selUnits.length > 0 &&
              this.battlePoints.length > 1
            ) {
              this.executeBattlePlan();
              this.togglePlanMode();
              return;
            } else if (
              !this.isDrag &&
              e.changedTouches.length > 0 &&
              !this.planMode
            ) {
              const t = document.elementFromPoint(
                e.changedTouches[0].clientX,
                e.changedTouches[0].clientY
              );
              if (t) {
                if (t.classList.contains("hex")) {
                  const h = MapSys.hexes[t.dataset.id];
                  if (h)
                    this.onHexClick({ button: 0, preventDefault: () => {} }, h);
                } else if (t.closest(".unit-grp")) {
                  const uEl = t.closest(".unit-grp");
                  const u = Game.units.find((x) => x.el === uEl);
                  if (u)
                    this.onHexClick(
                      { button: 0, preventDefault: () => {} },
                      u.hex
                    );
                }
              }
            }
          });
        },
        togglePlanMode: function () {
          this.planMode = !this.planMode;
          const btn = $("btn-plan-mode");
          if (this.planMode) {
            btn.classList.add("active");
            UI.notify("ä½œæˆ¦ãƒ¢ãƒ¼ãƒ‰: ON (ãªãã£ã¦ç§»å‹•)", "warn");
          } else {
            btn.classList.remove("active");
            UI.notify("ä½œæˆ¦ãƒ¢ãƒ¼ãƒ‰: OFF");
          }
        },
        updateBoxSelect: function (e) {
          const box = $("select-box");
          const x = Math.min(this.sx, e.clientX),
            y = Math.min(this.sy, e.clientY);
          const w = Math.abs(e.clientX - this.sx),
            h = Math.abs(e.clientY - this.sy);
          box.style.left = x + "px";
          box.style.top = y + "px";
          box.style.width = w + "px";
          box.style.height = h + "px";
          box.style.display = "block";
        },
        finishBoxSelect: function () {
          const b = $("select-box").getBoundingClientRect();
          const mapWrapRect = this.mapWrapEl.getBoundingClientRect();
          this.selUnits = Game.units.filter((u) => {
            if (u.tag !== Game.player) return false;
            const sx = u.x * Renderer.s + Renderer.x + mapWrapRect.left;
            const sy = u.y * Renderer.s + Renderer.y + mapWrapRect.top;
            return (
              sx >= b.left && sx <= b.right && sy >= b.top && sy <= b.bottom
            );
          });
          this.hlUnits();
        },
        startBattleLine: function (ptObj) {
          const pt = this.screenToWorld(ptObj.clientX, ptObj.clientY);
          this.battlePoints.push(pt);
          if (this.battleLineEl) this.battleLineEl.remove();
          this.battleLineEl = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "polyline"
          );
          this.battleLineEl.setAttribute("class", "battle-line");
          Renderer.uiLayer.appendChild(this.battleLineEl);
        },
        updateBattleLine: function (ptObj) {
          const pt = this.screenToWorld(ptObj.clientX, ptObj.clientY);
          const last = this.battlePoints[this.battlePoints.length - 1];
          if (!last || Math.hypot(pt.x - last.x, pt.y - last.y) > 10) {
            this.battlePoints.push(pt);
            const ptsStr = this.battlePoints
              .map((p) => `${p.x},${p.y}`)
              .join(" ");
            this.battleLineEl.setAttribute("points", ptsStr);
          }
        },
        executeBattlePlan: function () {
          if (!this.battleLineEl) return;
          this.battleLineEl.remove();
          this.battleLineEl = null;
          if (this.battlePoints.length < 2) return;

          // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ˜ãƒƒã‚¯ã‚¹æ¤œå‡ºï¼ˆåˆ¤å®šå¼·åŒ–ï¼‰
          const targetHexes = [];
          this.battlePoints.forEach((pt) => {
            let closest = null,
              minD = Infinity;
            MapSys.hexes.forEach((h) => {
              if (Math.abs(h.x - pt.x) > 80 || Math.abs(h.y - pt.y) > 80)
                return;
              const d = (h.x - pt.x) ** 2 + (h.y - pt.y) ** 2;
              if (d < 2500) {
                if (d < minD) {
                  minD = d;
                  closest = h;
                }
              }
            });
            if (closest && !targetHexes.includes(closest))
              targetHexes.push(closest);
          });

          if (targetHexes.length === 0) {
            UI.notify("æœ‰åŠ¹ãªç§»å‹•å…ˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", "warn");
            return;
          }

          // è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆç§»å‹•å…ˆã‚’å…‰ã‚‰ã›ã‚‹ï¼‰
          targetHexes.forEach((h) => {
            const m = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "circle"
            );
            m.setAttribute("cx", h.x);
            m.setAttribute("cy", h.y);
            m.setAttribute("r", 5);
            m.setAttribute("fill", "#ffca28");
            m.style.opacity = "1";
            m.style.transition = "opacity 1s";
            Renderer.uiLayer.appendChild(m);
            setTimeout(() => {
              m.style.opacity = "0";
              setTimeout(() => m.remove(), 1000);
            }, 500);
          });

          const sortedUnits = [...this.selUnits].sort((a, b) => a.y - b.y);
          let moveCount = 0;
          sortedUnits.forEach((u, i) => {
            const targetIndex = ~~(
              (i / sortedUnits.length) *
              targetHexes.length
            );
            const target = targetHexes[targetIndex];
            const path = this.findPath(u.hex, target, u.tag, 5000);
            if (path && path.length > 0) {
              u.path = path;
              u.state = "moving";
              moveCount++;
            }
          });
          if (moveCount > 0) UI.notify(`${moveCount} å¸«å›£ãŒä½œæˆ¦è¡Œå‹•ã‚’é–‹å§‹`);
          else UI.notify("ç§»å‹•çµŒè·¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ", "warn");
        },
        screenToWorld: function (sx, sy) {
          const rect = this.mapWrapEl.getBoundingClientRect();
          return {
            x: (sx - rect.left - Renderer.x) / Renderer.s,
            y: (sy - rect.top - Renderer.y) / Renderer.s,
          };
        },
        onHexClick: function (e, hex) {
          if (e.button === 0) {
            if (hex.owner && hex.owner !== "_SEA") {
              Game.selected = hex.owner;
              UI.updateSidebar();
            } else {
              Game.selected = null;
              UI.updateSidebar();
            }
            const myUnitsInHex = Game.units.filter(
              (u) => u.tag === Game.player && u.hex === hex
            );
            if (myUnitsInHex.length > 0) {
              if (this.isShift) {
                myUnitsInHex.forEach((u) => {
                  const idx = this.selUnits.indexOf(u);
                  if (idx >= 0) this.selUnits.splice(idx, 1);
                  else this.selUnits.push(u);
                });
              } else {
                this.selUnits = myUnitsInHex;
              }
            } else {
              if (!this.isShift) this.selUnits = [];
            }
            this.hlUnits();
          } else if (e.button === 2 && this.selUnits.length) {
            const uTag = this.selUnits[0].tag;
            const path = this.findPath(this.selUnits[0].hex, hex, uTag, 3000);
            if (path && path.length > 0) {
              this.selUnits.forEach((u) => {
                u.path = [...path];
                u.state = "moving";
              });
              const m = document.createElement("div");
              m.style.cssText = `position:absolute;left:${e.clientX}px;top:${e.clientY}px;width:10px;height:10px;background:#0f0;border-radius:50%;pointer-events:none;z-index:99;animation:fade 1s;`;
              document.body.appendChild(m);
              setTimeout(() => m.remove(), 1000);
            } else {
              UI.notify("ç§»å‹•ã§ãã¾ã›ã‚“", "warn");
            }
          }
        },
        hlUnits: function () {
          document
            .querySelectorAll(".unit-grp")
            .forEach((el) => el.classList.remove("selected"));
          this.selUnits.forEach((u) => u.el.classList.add("selected"));
          $("sel-count").innerText = this.selUnits.length;

          const btn = $("btn-plan-mode");
          if (this.selUnits.length > 0) {
            btn.style.display = "flex";
          } else {
            btn.style.display = "none";
            this.planMode = false;
            btn.classList.remove("active");
          }
        },
        findPath: function (start, end, unitTag, maxSearch = 200) {
          // æœ€å¤§æ¢ç´¢æ•°ã‚’æ¸›ã‚‰ã™
          // è·é›¢ãƒã‚§ãƒƒã‚¯
          const distSq = (start.x - end.x) ** 2 + (start.y - end.y) ** 2;
          if (distSq > 250000) return null; // 500ãƒ”ã‚¯ã‚»ãƒ«ä»¥ä¸Šé›¢ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«

          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚·ã‚¹ãƒ†ãƒ 
          const pathKey = `${start.id}-${end.id}-${unitTag}`;
          if (!this.pathCache) this.pathCache = new Map();

          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯ï¼ˆ10ç§’é–“æœ‰åŠ¹ï¼‰
          const cached = this.pathCache.get(pathKey);
          if (cached && Game.day - cached.day < 600) {
            return cached.path;
          }

          // ç°¡æ˜“ãƒ‘ã‚¹ï¼ˆç›´ç·šã«è¿‘ã„ï¼‰
          if (distSq < 10000) {
            // 100ãƒ”ã‚¯ã‚»ãƒ«ä»¥å†…
            const simplePath = this.findSimplePath(start, end, unitTag);
            if (simplePath) {
              this.pathCache.set(pathKey, { path: simplePath, day: Game.day });
              return simplePath;
            }
          }

          // A*ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
          const heuristic = (h1, h2) => {
            // ãƒãƒ³ãƒãƒƒã‚¿ãƒ³è·é›¢ã§é«˜é€ŸåŒ–
            return Math.abs(h1.x - h2.x) + Math.abs(h1.y - h2.y);
          };

          const openSet = new Map();
          const cameFrom = new Map();
          const gScore = new Map();
          const fScore = new Map();

          gScore.set(start.id, 0);
          fScore.set(start.id, heuristic(start, end));

          // å„ªå…ˆåº¦ä»˜ãã‚­ãƒ¥ãƒ¼ï¼ˆé…åˆ— + ã‚½ãƒ¼ãƒˆï¼‰
          const openNodes = [{ node: start, f: fScore.get(start.id) }];

          let limit = 0;

          while (openNodes.length > 0 && limit++ < maxSearch) {
            // æœ€å°fã‚¹ã‚³ã‚¢ã®ãƒãƒ¼ãƒ‰ã‚’å–å¾—
            openNodes.sort((a, b) => a.f - b.f);
            const current = openNodes.shift().node;

            if (current === end) {
              // ãƒ‘ã‚¹å†æ§‹ç¯‰
              const path = [];
              let node = end;
              while (node && node !== start) {
                path.unshift(node);
                node = cameFrom.get(node.id);
              }

              if (path.length > 0) {
                this.pathCache.set(pathKey, { path, day: Game.day });

                // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºåˆ¶é™
                if (this.pathCache.size > 500) {
                  const firstKey = this.pathCache.keys().next().value;
                  this.pathCache.delete(firstKey);
                }
              }

              return path;
            }

            openSet.delete(current.id);

            // éš£æ¥ãƒãƒ¼ãƒ‰ã®æ¢ç´¢
            for (const neighbor of current.adj) {
              if (!neighbor) continue;

              // ç§»å‹•å¯å¦ãƒã‚§ãƒƒã‚¯
              if (
                neighbor.owner !== "_SEA" &&
                neighbor.owner !== unitTag &&
                !Game.isWar(unitTag, neighbor.owner) &&
                !Game.isAlly(unitTag, neighbor.owner)
              ) {
                continue;
              }

              const moveCost = neighbor.type === "sea" ? 5 : 1;
              const tentativeGScore =
                (gScore.get(current.id) || Infinity) + moveCost;

              if (tentativeGScore < (gScore.get(neighbor.id) || Infinity)) {
                cameFrom.set(neighbor.id, current);
                gScore.set(neighbor.id, tentativeGScore);
                fScore.set(
                  neighbor.id,
                  tentativeGScore + heuristic(neighbor, end)
                );

                if (!openSet.has(neighbor.id)) {
                  openSet.set(neighbor.id, true);
                  openNodes.push({
                    node: neighbor,
                    f: fScore.get(neighbor.id),
                  });
                }
              }
            }
          }

          // ãƒ‘ã‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«nullã‚’ä¿å­˜
          this.pathCache.set(pathKey, { path: null, day: Game.day });
          return null;
        },

        // ç°¡æ˜“ãƒ‘ã‚¹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°é–¢æ•°
        findSimplePath: function (start, end, unitTag) {
          const path = [];
          let current = start;

          // æœ€å¤§10ã‚¹ãƒ†ãƒƒãƒ—ã¾ã§
          for (let i = 0; i < 10; i++) {
            let bestNeighbor = null;
            let bestDist = Infinity;

            // æœ€ã‚‚ã‚´ãƒ¼ãƒ«ã«è¿‘ã„éš£æ¥ãƒ˜ãƒƒã‚¯ã‚¹ã‚’é¸æŠ
            for (const neighbor of current.adj) {
              if (!neighbor) continue;

              // ç§»å‹•å¯å¦ãƒã‚§ãƒƒã‚¯
              if (
                neighbor.owner !== "_SEA" &&
                neighbor.owner !== unitTag &&
                !Game.isWar(unitTag, neighbor.owner) &&
                !Game.isAlly(unitTag, neighbor.owner)
              ) {
                continue;
              }

              const dist =
                (neighbor.x - end.x) ** 2 + (neighbor.y - end.y) ** 2;
              if (dist < bestDist) {
                bestDist = dist;
                bestNeighbor = neighbor;
              }
            }

            if (!bestNeighbor || current === end) break;

            path.push(bestNeighbor);
            current = bestNeighbor;

            if (current === end) break;
          }

          return path.length > 0 ? path : null;
        },
      };

      const Renderer = {
        x: 0,
        y: 0,
        s: 1,
        layer: null,
        uiLayer: null,
        gameSvg: null,
        update: function () {
          $(
            "game-svg"
          ).style.transform = `translate(${this.x}px, ${this.y}px) scale(${this.s})`;
        },
        addUnit: function (u) {
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.className.baseVal = "unit-grp";
          const inner = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );
          inner.classList.add("unit-inner");
          inner.innerHTML = `<rect class="unit-box" x="-11" y="-7"/><rect class="unit-bar" x="-10" y="5" width="20" height="2"/><rect class="unit-org-bar" x="-10" y="3" width="20" height="2"/><text class="unit-icon" y="3">${u.icon}</text>`;
          g.appendChild(inner);
          g.setAttribute("transform", `translate(${u.x},${u.y})`);
          this.layer.appendChild(g);
          u.el = g;
          u.innerEl = inner;
          u.bar = inner.querySelector(".unit-bar");
          u.orgBar = inner.querySelector(".unit-org-bar");

          // è£œçµ¦åˆ‡ã‚Œã‚¢ã‚¤ã‚³ãƒ³
          const noSupply = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          noSupply.textContent = "!";
          noSupply.setAttribute("class", "no-supply-icon");
          noSupply.setAttribute("x", "6");
          noSupply.setAttribute("y", "-3");
          noSupply.style.display = "none";
          inner.appendChild(noSupply);
          u.noSupplyIcon = noSupply;
        },
        updateUnit: function (u) {
          // ç”»é¢å¤–ã®ãƒ¦ãƒ‹ãƒƒãƒˆã®æ›´æ–°ã‚’ã‚¹ã‚­ãƒƒãƒ— (ã‚«ãƒªãƒ³ã‚°)
          const mapWrapRect = Input.mapWrapEl.getBoundingClientRect();
          const screenX = u.x * this.s + this.x;
          const screenY = u.y * this.s + this.y;

          // ç”»é¢ã®å°‘ã—å¤–å´ã‚‚è€ƒæ…®ã—ã¦æç”»ç¯„å›²ã‚’åºƒã’ã‚‹
          const padding = 50;
          if (
            screenX < -padding ||
            screenX > mapWrapRect.width + padding ||
            screenY < -padding ||
            screenY > mapWrapRect.height + padding
          ) {
            // ç”»é¢å¤–ã®å ´åˆã€ãƒ¦ãƒ‹ãƒƒãƒˆè¦ç´ ã‚’éè¡¨ç¤ºã«ã™ã‚‹
            if (u.el.style.display !== "none") {
              u.el.style.display = "none";
            }
            return;
          }
          // ç”»é¢å†…ã«æˆ»ã£ã¦ããŸå ´åˆã€è¡¨ç¤ºã™ã‚‹
          if (u.el.style.display === "none") {
            u.el.style.display = "";
          }

          // Canvas: å…¨ãƒ¦ãƒ‹ãƒƒãƒˆæç”» (ã‚«ãƒªãƒ³ã‚°ãªã—)
          if (
            Math.abs(u.x - u.lastRx) > 0.5 ||
            Math.abs(u.y - u.lastRy) > 0.5
          ) {
            u.el.setAttribute("transform", `translate(${u.x},${u.y})`);
            u.lastRx = u.x;
            u.lastRy = u.y;
          }
          const hpW = (u.hp / 100) * 20;
          const orgW = (u.org / u.maxOrg) * 20;
          if (Math.abs(u.lastHpW - hpW) > 1) {
            u.bar.setAttribute("width", Math.max(0, hpW));
            u.lastHpW = hpW;
          }
          if (Math.abs(u.lastOrgW - orgW) > 1) {
            u.orgBar.setAttribute("width", Math.max(0, orgW));
            u.lastOrgW = orgW;
          }

          // è£œçµ¦è¡¨ç¤º
          if (u.supply < 30) {
            if (u.noSupplyIcon.style.display === "none")
              u.noSupplyIcon.style.display = "block";
          } else {
            if (u.noSupplyIcon.style.display === "block")
              u.noSupplyIcon.style.display = "none";
          }
        },
      };

      const Designer = {
        current: { bat: [], sup: [] },
        open: function () {
          const p = Game.countries[Game.player];
          if (!p) return;
          this.current = { bat: [...p.template.bat], sup: [...p.template.sup] };
          const xpEl = $("ds-xp");
          if (xpEl) xpEl.innerText = ~~p.xp;
          $("design-modal").style.display = "flex";
          this.renderOptions();
          this.updateGrid();
        },
        renderOptions: function () {
          const batDiv = $("opt-battalions");
          const supDiv = $("opt-support");
          if (!batDiv || !supDiv) return;
          batDiv.innerHTML = "";
          supDiv.innerHTML = "";
          Object.keys(DB.UnitTypes).forEach((key) => {
            const u = DB.UnitTypes[key];
            const el = $c("div", "unit-opt");
            el.innerHTML = `<span class="unit-opt-icon">${u.icon}</span><span>${u.name}</span><span style="font-size:10px;color:#aaa;margin-left:auto">Cost:${u.cost}</span>`;
            el.onclick = () => this.addUnit(key, u.type);
            if (u.type === "bat") batDiv.appendChild(el);
            else supDiv.appendChild(el);
          });
        },
        addUnit: function (id, type) {
          if (type === "bat") {
            if (this.current.bat.length < 9) {
              this.current.bat.push(id);
              this.updateGrid();
            } else UI.notify("ä¸»åŠ›å¤§éšŠã¯ã“ã‚Œä»¥ä¸Šè¿½åŠ ã§ãã¾ã›ã‚“", "warn");
          } else {
            if (this.current.sup.length < 3 && !this.current.sup.includes(id)) {
              this.current.sup.push(id);
              this.updateGrid();
            } else
              UI.notify("æ”¯æ´ä¸­éšŠã¯è¿½åŠ ã§ããªã„ã‹ã€æ—¢ã«å­˜åœ¨ã—ã¾ã™", "warn");
          }
        },
        removeUnit: function (idx, type) {
          if (type === "bat") this.current.bat.splice(idx, 1);
          else this.current.sup.splice(idx, 1);
          this.updateGrid();
        },
        updateGrid: function () {
          const gb = $("grid-bat");
          const gs = $("grid-sup");
          if (!gb || !gs) return;
          gb.innerHTML = "";
          gs.innerHTML = "";
          this.current.bat.forEach((uid, i) => {
            const u = DB.UnitTypes[uid];
            const el = $c("div", "slot filled");
            el.innerHTML = `${u.icon}<div class="rm" onclick="event.stopPropagation();Designer.removeUnit(${i},'bat')">Ã—</div>`;
            gb.appendChild(el);
          });
          for (let i = this.current.bat.length; i < 6; i++) {
            gb.appendChild($c("div", "slot"));
          }
          this.current.sup.forEach((uid, i) => {
            const u = DB.UnitTypes[uid];
            const el = $c("div", "slot filled");
            el.innerHTML = `${u.icon}<div class="rm" onclick="event.stopPropagation();Designer.removeUnit(${i},'sup')">Ã—</div>`;
            gs.appendChild(el);
          });
          for (let i = this.current.sup.length; i < 3; i++) {
            gs.appendChild($c("div", "slot"));
          }
          this.calcPreview();
        },
        calcPreview: function () {
          const s = Game.calcStats(this.current);
          if ($("ds-atk-s")) $("ds-atk-s").innerText = s.sa.toFixed(1);
          if ($("ds-atk-h")) $("ds-atk-h").innerText = s.ha.toFixed(1);
          if ($("ds-def")) $("ds-def").innerText = s.def.toFixed(1);
          if ($("ds-brk")) $("ds-brk").innerText = s.brk.toFixed(1);
          if ($("ds-arm")) $("ds-arm").innerText = s.arm.toFixed(1);
          if ($("ds-cost")) $("ds-cost").innerText = s.cost.toFixed(0);
        },
        save: function () {
          const p = Game.countries[Game.player];
          const cost = 10;
          if (p.xp < cost) {
            UI.notify(`é™¸è»çµŒé¨“å€¤ãŒè¶³ã‚Šã¾ã›ã‚“ (å¿…è¦: ${cost})`, "warn");
            return;
          }
          if (this.current.bat.length === 0) {
            UI.notify("å°‘ãªãã¨ã‚‚1ã¤ã®ä¸»åŠ›å¤§éšŠãŒå¿…è¦ã§ã™", "warn");
            return;
          }
          p.xp -= cost;
          p.template = {
            bat: [...this.current.bat],
            sup: [...this.current.sup],
          };
          UI.notify("å¸«å›£ç·¨æˆã‚’ä¿å­˜ã—ã¾ã—ãŸ", "success");
          UI.closeDesigner();
          UI.update();
        },
      };
      const Game = {
        day: 1,
        speed: 1,
        running: false,
        player: "",
        countries: {},
        units: [],
        wars: [],
        tension: 0,
        aiTimer: 0,
        lastTickTime: 0,
        tickInterval: 100,
        geoData: null,
        isMapOverridden: false,
        unitGrid: new Map(),
        lastSuperEventDay: 0,

        init: async function () {
          if (!this.isMapOverridden) {
            await this.loadMapData();
          }
          Input.init();
          this.initCountries();
          this.initMap();
          UI.showStartScreen();
        },
        startGame: function (playerTag) {
          this.player = playerTag;
          this.countries[this.player].col = "#b71c1c";
          MapSys.hexes.forEach((h) => {
            if (h.owner === this.player) h.el.setAttribute("fill", "#b71c1c");
          });
          $("start-screen").style.display = "none";
          this.spawnInitialUnits();

          const cap = this.countries[this.player].capital;
          if (cap) {
            const wrapW = Input.mapWrapEl.clientWidth;
            const wrapH = Input.mapWrapEl.clientHeight;
            Renderer.x = wrapW / 2 - cap.x * Renderer.s;
            Renderer.y = wrapH / 2 - cap.y * Renderer.s;
            Renderer.update();
          }

          UI.init();
          this.setSpeed(1);
          this.lastTickTime = performance.now();
          requestAnimationFrame(this.loop.bind(this));
        },
        loadMapData: async function () {
          try {
            const res = await fetch(
              "https://raw.githubusercontent.com/dataofjapan/land/master/japan.geojson"
            );
            if (!res.ok) throw new Error("Network response was not ok");
            this.geoData = await res.json();
          } catch (e) {
            alert("ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
          }
        },
        // Game.loop é–¢æ•°ã‚’ä¿®æ­£
        loop: function (currentTime) {
          if (!this.running) {
            this.lastTickTime = currentTime;
            requestAnimationFrame(this.loop.bind(this));
            return;
          }

          const deltaTime = currentTime - this.lastTickTime;

          // 60FPSã§å›ºå®šï¼ˆç´„16.67msé–“éš”ï¼‰
          if (deltaTime >= 16.67) {
            // ã‚²ãƒ¼ãƒ ãƒ†ã‚£ãƒƒã‚¯ã‚’ã¾ã¨ã‚ã¦å‡¦ç†
            const ticksToProcess = Math.min(Math.floor(deltaTime / 16.67), 5); // æœ€å¤§5ãƒ†ã‚£ãƒƒã‚¯ã¾ã§

            for (let i = 0; i < ticksToProcess; i++) {
              this.processTick();
            }
            this.lastTickTime = currentTime;

            // æç”»æ›´æ–°ï¼ˆãƒ†ã‚£ãƒƒã‚¯å‡¦ç†å¾Œï¼‰
            this.updateUnits();
            UI.update();

            // ãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã§ã¯ãªãå®šæœŸçš„ã«ï¼‰
            if (Game.day % 60 === 0) {
              this.cleanupMemory();
            }
          }

          requestAnimationFrame(this.loop.bind(this));
        },
        cleanupMemory: function () {
          // æœªä½¿ç”¨ã®DOMè¦ç´ ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          const svg = document.getElementById("game-svg");
          if (svg) {
            const elements = svg.querySelectorAll(".unit-grp, .hex");
            elements.forEach((el) => {
              if (!el.parentNode) {
                el.remove();
              }
            });
          }

          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
          if (this.pathCache && this.pathCache.size > 1000) {
            const keys = Array.from(this.pathCache.keys());
            for (let i = 0; i < 500; i++) {
              this.pathCache.delete(keys[i]);
            }
          }

          // ãƒ¦ãƒ‹ãƒƒãƒˆã‚°ãƒªãƒƒãƒ‰ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          this.cleanupUnitGrid();

          // å¼·åˆ¶ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆé–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ç”¨ï¼‰
          if (typeof window.gc === "function") {
            window.gc();
          }
        },

        cleanupUnitGrid: function () {
          // ç©ºã®ã‚°ãƒªãƒƒãƒ‰ã‚»ãƒ«ã‚’å‰Šé™¤
          for (const [key, units] of this.unitGrid.entries()) {
            if (units.length === 0) {
              this.unitGrid.delete(key);
            }
          }
        },
        processTick: function () {
          this.day++;
          const tags = Object.keys(this.countries);

          // è£œçµ¦è¨ˆç®—ï¼ˆæ¯æ—¥ã§ã¯ãªã20æ—¥ã«1å›ã«é »åº¦ã‚’ä¸‹ã’ã‚‹ï¼‰
          if (this.day % 20 === 0) this.calcSupplyAll();

          tags.forEach((tag) => {
            if (tag === "_SEA") return;
            const c = this.countries[tag];
            if (c.provs.length === 0 && !c.dead) return;

            // çµŒæ¸ˆå‡¦ç†
            c.pp += (0.5 + c.fac / 50) * (1 + (c.ppGainBonus || 0));
            c.eq +=
              c.fac *
              15 *
              (1 + (c.facProdBonus || 0)) *
              (1 + (c.eqProdBonus || 0));
            if (c.eq > 200000) c.eq = 200000;

            // å¹³å’Œã‚¿ã‚¤ãƒãƒ¼
            c.peaceTimer = (c.peaceTimer || 0) + 1;

            // çµŒé¨“å€¤ï¼ˆæˆ¦é—˜ä¸­ã®ã¿é »ç¹ã«æ›´æ–°ï¼‰
            const fightingUnits = this.units.filter(
              (u) => u.tag === tag && u.isFighting
            );
            if (fightingUnits.length > 0) {
              c.xp += 0.3 * (1 + (c.xpGainBonus || 0));
            } else if (this.day % 10 === 0) {
              c.xp += 0.05 * (1 + (c.xpGainBonus || 0));
            }

            if (c.xp > 500) c.xp = 500;

            // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å‡¦ç†
            if (c.focus) {
              c.focusProg++;
              if (c.focusProg >= c.focus.cost) this.completeFocus(c);
            } else if (c.buildingFactory) {
              c.buildingFactory.progress += 1 + (c.factoryBuildSpeedBonus || 0);
              if (c.buildingFactory.progress >= c.buildingFactory.cost) {
                c.fac++;
                c.pp -= 20;
                if (tag === this.player)
                  UI.notify(`${c.name} ã§å·¥å ´ãŒå®Œæˆ`, "success");
                c.buildingFactory = null;
              }
            }

            // äººçš„è³‡æºï¼ˆ30æ—¥ã”ã¨ï¼‰
            if (this.day % 30 === 0 && c.mp < 1e6) c.mp += c.fac * 100;
          });

          // AIå‡¦ç†ã®é »åº¦ã‚’ä¸‹ã’ã‚‹
          this.aiTimer++;
          if (this.aiTimer > 2) {
            // å…ƒã¯4ã€ã•ã‚‰ã«å€ã«
            const aiBatch = 2; // ä¸€åº¦ã«å‡¦ç†ã™ã‚‹AIæ•°ã‚’æ¸›ã‚‰ã™
            const startIdx = (this.day * aiBatch) % tags.length;

            for (let i = 0; i < aiBatch; i++) {
              const t = tags[(startIdx + i) % tags.length];
              if (t !== this.player && t !== "_SEA") {
                // ã•ã‚‰ã«ã€ä¸€éƒ¨ã®å›½ã®ã¿è©³ç´°ãªAIæ€è€ƒã‚’å®Ÿè¡Œ
                const c = this.countries[t];
                if (c && c.fac > 2) {
                  // å·¥å ´ãŒ2ä»¥ä¸Šã®å›½ã®ã¿è©³ç´°AI
                  AI.runCountry(t);
                }
              }
            }
            this.aiTimer = 0;
          }

          // ãƒ¦ãƒ‹ãƒƒãƒˆæ›´æ–°ã¯æ¯ãƒ†ã‚£ãƒƒã‚¯ã§ã¯ãªãã€å¿…è¦æ™‚ã«ã®ã¿
          if (this.needsUnitUpdate || this.day % 3 === 0) {
            this.updateUnits();
            this.needsUnitUpdate = false;
          }

          UI.update();
        },
        initCountries: function () {
          this.countries = {};
          const ideologies = [
            "çœŒæ°‘ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ",
            "å¤§æ”¿ç¿¼è³›ä¼š",
            "ç«‹æ†²è‡ªæ²»",
            "ç‹¬ç«‹æ´¾",
          ];
          if (this.geoData && this.geoData.features) {
            this.geoData.features.forEach((f) => {
              const props = f.properties;
              const name = props.nam_ja || props.nam || "Unknown";
              const id = props.id
                ? "P" + props.id
                : name.replace(/[^a-zA-Z0-9]/g, "");
              this.countries[id] = {
                tag: id,
                name: name,
                col: nextColor(),
                flag: "ğŸ‡¯ğŸ‡µ",
                mp: 50000 + Math.random() * 50000,
                fac: 2 + Math.floor(Math.random() * 3),
                eq: 5000,
                xp: 10,
                doctrine: "balanced",
                provs: [],
                pp: 50,
                st: 80,
                ws: 10,
                focus: null,
                focusProg: 0,
                completedFocuses: [],
                faction: null,
                template: DB.AITemplates.basic_inf,
                buildingFactory: null,
                treeType: "GENERIC",
                peaceTimer: 0,
                supplyMap: new Set(),
                ideology:
                  ideologies[Math.floor(Math.random() * ideologies.length)],
              };
              if (name.includes("Gunma") || name.includes("ç¾¤é¦¬")) {
                this.countries[id].name = "ã‚°ãƒ³ãƒãƒ¼å¸å›½";
                this.countries[id].flag = "ğŸ¹";
                this.countries[id].ideology = "æœªé–‹éƒ¨æ—åˆ¶";
                this.countries[id].mp = 200000;
                this.countries[id].col = "#5d4037";
              } else if (name.includes("Hyogo") || name.includes("å…µåº«")) {
                this.countries[id].name = "ãƒ’ãƒ§ãƒ¼ã‚´ã‚¹ãƒ©ãƒ“ã‚¢é€£é‚¦";
                this.countries[id].flag = "âš“";
                this.countries[id].ideology = "å¤šæ°‘æ—é€£é‚¦";
                this.countries[id].st = 10;
                this.countries[id].fac += 5;
              } else if (name.includes("Ibaraki") || name.includes("èŒ¨åŸ")) {
                this.countries[id].name = "èŒ¨åŸ";
                this.countries[id].flag = "ğŸ ";
                this.countries[id].ideology = "èŒ¨åŸ"; // ã‚ãˆã¦æ™®é€š
                this.countries[id].mp += 50000; // ã§ã‚‚å¼·ã„
              } else if (name.includes("Chiba") || name.includes("åƒè‘‰")) {
                this.countries[id].name = "å¸æ”¿åƒè‘‰";
                this.countries[id].flag = "ğŸ¥œ";
                this.countries[id].ideology = "å¤¢ã®å›½å°‚åˆ¶";
                this.countries[id].fac += 8;
              } else if (name.includes("Aichi") || name.includes("æ„›çŸ¥")) {
                this.countries[id].name = "æ„›çŸ¥å¸å›½";
                this.countries[id].flag = "ğŸ¤";
                this.countries[id].ideology = "è‡ªå‹•è»Šè¦‡æ¨©";
                this.countries[id].fac = 22;
                this.countries[id].mp = 700000;
              } else if (name.includes("Shimane") || name.includes("å³¶æ ¹")) {
                this.countries[id].name = "ç¬¬ä¸‰äººé¡";
                this.countries[id].flag = "ğŸ‘½";
                this.countries[id].ideology = "è¶…è¶Šè€…";
              } else if (name.includes("Saitama") || name.includes("åŸ¼ç‰")) {
                this.countries[id].name = "å½©ã®å›½ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ³ã‚¹";
                this.countries[id].flag = "ğŸ•Šï¸";
              } else if (name.includes("Kagawa") || name.includes("é¦™å·")) {
                this.countries[id].name = "ã†ã©ã‚“çœŒ";
                this.countries[id].flag = "ğŸœ";
              } else if (name.includes("Tottori") || name.includes("é³¥å–")) {
                this.countries[id].name = "é³¥å–ç ‚ä¸˜å¸å›½";
                this.countries[id].flag = "ğŸª";
              }
              // ä¸»è¦éƒ½å¸‚
              else if (name.includes("æ±äº¬") || name.includes("Tokyo")) {
                this.countries[id].fac = 25;
                this.countries[id].mp = 1000000;
                this.countries[id].name = "å¸éƒ½æ±äº¬";
                this.countries[id].ideology = "ä¸­å¤®æ”¿åºœ";
              } else if (name.includes("å¤§é˜ª") || name.includes("Osaka")) {
                this.countries[id].fac = 20;
                this.countries[id].mp = 800000;
                this.countries[id].name = "å¤§é˜ªéƒ½";
              } else if (name.includes("ç¥å¥ˆå·") || name.includes("Kanagawa")) {
                this.countries[id].fac = 15;
                this.countries[id].mp = 700000;
              } else if (name.includes("ç¦å²¡") || name.includes("Fukuoka")) {
                this.countries[id].fac = 12;
                this.countries[id].mp = 500000;
                this.countries[id].name = "ä¿®ç¾…ã®å›½";
                this.countries[id].flag = "ğŸ’£";
              } else if (name.includes("åŒ—æµ·é“") || name.includes("Hokkaido")) {
                this.countries[id].fac = 10;
                this.countries[id].mp = 500000;
                this.countries[id].name = "åŒ—æµ·å…±å’Œå›½";
              }
            });
          }
        },
        calcStats: function (tmpl) {
          let s = {
            sa: 0,
            ha: 0,
            def: 0,
            brk: 0,
            arm: 0,
            prc: 0,
            org: 0,
            spd: 999,
            cost: 0,
          };
          if (!tmpl || !tmpl.bat.length) return s;
          let batCount = 0;
          tmpl.bat.forEach((t) => {
            const d = DB.UnitTypes[t];
            if (!d) return;
            s.sa += d.sa;
            s.ha += d.ha;
            s.def += d.def;
            s.brk += d.brk;
            s.cost += d.cost;
            s.org += d.org;
            if (d.arm > s.arm) s.arm = d.arm * 0.3 + s.arm * 0.7;
            if (d.prc > s.prc) s.prc = d.prc * 0.4 + s.prc * 0.6;
            if (d.spd < s.spd) s.spd = d.spd;
            batCount++;
          });
          if (batCount > 0) s.org /= batCount;
          else s.spd = 0;
          tmpl.sup.forEach((t) => {
            const d = DB.UnitTypes[t];
            if (!d) return;
            s.sa += d.sa;
            s.ha += d.ha;
            s.def += d.def;
            s.brk += d.brk;
            s.cost += d.cost;
          });
          let maxArm = 0;
          tmpl.bat.forEach((t) => {
            if (DB.UnitTypes[t].arm > maxArm) maxArm = DB.UnitTypes[t].arm;
          });
          s.arm = (s.arm + maxArm) / 2;
          return s;
        },
        spawnInitialUnits: function () {
          Object.values(this.countries).forEach((c) => {
            if (c.tag === "_SEA") return;
            const n = Math.min(10, Math.max(2, ~~(c.fac / 2)));
            for (let i = 0; i < n; i++)
              if (c.provs.length) this.spawnUnit(c.tag, c.capital, c.template);
          });
        },
        spawnUnit: function (tag, hex, template) {
          if (!hex) return;
          const tmplCopy = { bat: [...template.bat], sup: [...template.sup] };
          const stats = this.calcStats(tmplCopy);
          const u = {
            id: Math.random().toString(36),
            tag: tag,
            x: hex.x,
            y: hex.y,
            hex: hex,
            state: "idle",
            path: [],
            hp: 100,
            org: stats.org,
            maxOrg: stats.org,
            template: tmplCopy,
            stats: stats,
            icon: DB.UnitTypes[tmplCopy.bat[0]].icon,
            lastRx: 0,
            lastRy: 0,
            lastHpW: 0,
            lastOrgW: 0,
            isFighting: false,
            supply: 100,
          };
          this.units.push(u);
          this.addToGrid(u, hex);
          Renderer.addUnit(u);
        },
        addToGrid: function (u, hex) {
          if (!this.unitGrid.has(hex.id)) this.unitGrid.set(hex.id, []);
          this.unitGrid.get(hex.id).push(u);
        },
        removeFromGrid: function (u, hex) {
          if (!this.unitGrid.has(hex.id)) return;
          const arr = this.unitGrid.get(hex.id);
          const idx = arr.indexOf(u);
          if (idx !== -1) arr.splice(idx, 1);
          if (arr.length === 0) this.unitGrid.delete(hex.id);
        },
        getEnemyInHex: function (hex, myTag) {
          if (!this.unitGrid.has(hex.id)) return null;
          const enemies = this.unitGrid
            .get(hex.id)
            .filter((u) => u.tag !== myTag && this.isWar(u.tag, myTag));
          return enemies.length > 0 ? enemies[0] : null;
        },
        calcSupplyAll: function () {
          Object.keys(this.countries).forEach((tag) => {
            const c = this.countries[tag];
            if (!c.capital) return;
            const q = [c.capital];
            const visited = new Set();
            visited.add(c.capital.id);
            let head = 0;
            while (head < q.length) {
              const curr = q[head++];
              curr.adj.forEach((n) => {
                if (n.owner === tag && !visited.has(n.id)) {
                  visited.add(n.id);
                  q.push(n);
                }
              });
            }
            c.supplyMap = visited;
          });
        },
        updateUnits: function () {
          const visibleUnits = [];
          const mapWrapRect = Input.mapWrapEl.getBoundingClientRect();
          const padding = 150; // å°‘ã—ä½™è£•ã‚’æŒãŸã›ã‚‹

          // 1. ã¾ãšç”Ÿå­˜ãƒã‚§ãƒƒã‚¯ã¨ç”»é¢å†…ãƒ¦ãƒ‹ãƒƒãƒˆã®é¸åˆ¥
          for (let i = this.units.length - 1; i >= 0; i--) {
            const u = this.units[i];

            // ç”Ÿå­˜ãƒã‚§ãƒƒã‚¯
            if (u.hp <= 0) {
              this.removeFromGrid(u, u.hex);
              if (u.el) u.el.remove();

              // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢
              u.el = null;
              u.innerEl = null;
              u.bar = null;
              u.orgBar = null;
              u.noSupplyIcon = null;

              this.units.splice(i, 1);
              continue;
            }

            // ç”»é¢å†…ã‹ã©ã†ã‹ã‚’åˆ¤å®š
            const screenX = u.x * Renderer.s + Renderer.x;
            const screenY = u.y * Renderer.s + Renderer.y;

            const isVisible =
              screenX > -padding &&
              screenX < mapWrapRect.width + padding &&
              screenY > -padding &&
              screenY < mapWrapRect.height + padding;

            if (isVisible) {
              visibleUnits.push(u);
            } else {
              // ç”»é¢å¤–ã®ãƒ¦ãƒ‹ãƒƒãƒˆã¯éè¡¨ç¤º
              if (u.el && u.el.style.display !== "none") {
                u.el.style.display = "none";
              }

              // ç”»é¢å¤–ã§ã‚‚åŸºæœ¬çš„ãªç§»å‹•å‡¦ç†ã¯è¡Œã†ï¼ˆç°¡æ˜“ç‰ˆï¼‰
              if (
                u.state === "moving" &&
                u.path.length > 0 &&
                this.day % 2 === 0
              ) {
                this.updateOffscreenUnit(u);
              }
            }
          }

          // 2. ç”»é¢å†…ã®ãƒ¦ãƒ‹ãƒƒãƒˆã®ã¿è©³ç´°æ›´æ–°
          for (let i = 0; i < visibleUnits.length; i++) {
            const u = visibleUnits[i];

            // è¡¨ç¤ºã‚’æœ‰åŠ¹åŒ–
            if (u.el && u.el.style.display !== "") {
              u.el.style.display = "";
            }

            // ç§»å‹•å‡¦ç†
            if (u.state === "moving" && u.path.length) {
              const next = u.path[0];
              if (!next) {
                u.path = [];
                u.state = "idle";
                continue;
              }

              // æ•µãƒã‚§ãƒƒã‚¯
              const enemyHere = this.getEnemyInHex(u.hex, u.tag);
              const enemyInNext =
                Math.hypot(next.x - u.x, next.y - u.y) < 15
                  ? this.getEnemyInHex(next, u.tag)
                  : null;
              const enemy = enemyHere || enemyInNext;

              if (enemy) {
                if (!u.isFighting) {
                  if (u.innerEl) u.innerEl.classList.add("fighting");
                  u.isFighting = true;
                }

                // æˆ¦é—˜å‡¦ç†ï¼ˆé »åº¦ã‚’ä¸‹ã’ã‚‹ï¼‰
                if (Math.random() < 0.1) {
                  // å…ƒã¯.15
                  const enemyHardness = enemy.stats.arm > 5 ? 0.6 : 0.1;
                  const myHardness = u.stats.arm > 5 ? 0.6 : 0.1;

                  let myAtk =
                    u.stats.sa * (1 - enemyHardness) +
                    u.stats.ha * enemyHardness;
                  let enemyAtk =
                    enemy.stats.sa * (1 - myHardness) +
                    enemy.stats.ha * myHardness;

                  // è£œçµ¦ãƒšãƒŠãƒ«ãƒ†ã‚£é©ç”¨
                  const supplyPenalty = Math.max(0.1, u.supply / 100);
                  myAtk *= supplyPenalty;

                  const myDmg = Math.max(
                    1,
                    (myAtk - enemy.stats.def / 4) * (0.8 + Math.random() * 0.4)
                  );
                  const enemyDmg = Math.max(
                    1,
                    (enemyAtk - u.stats.brk / 4) * (0.8 + Math.random() * 0.4)
                  );

                  enemy.org -= myDmg * 0.8;
                  enemy.hp -= myDmg * 0.2;
                  u.org -= enemyDmg * 0.8;
                  u.hp -= enemyDmg * 0.2;

                  if (u.org <= 0) {
                    u.org = 0;
                    u.state = "idle";
                    u.path = [];
                    if (u.isFighting && u.innerEl) {
                      u.innerEl.classList.remove("fighting");
                      u.isFighting = false;
                    }
                  }
                }
                continue;
              } else {
                if (u.isFighting && u.innerEl) {
                  u.innerEl.classList.remove("fighting");
                  u.isFighting = false;
                }
              }

              // ç§»å‹•è¨ˆç®—
              const unitSpeed =
                u.stats.spd *
                (u.org / u.maxOrg) *
                Math.max(0.1, u.supply / 100);
              const terrainMoveCost = DB.Terrain[next.type]?.moveCost || 1;
              const spd = unitSpeed / terrainMoveCost;

              const dx = next.x - u.x,
                dy = next.y - u.y;
              const dist = Math.hypot(dx, dy);

              // ãƒ˜ãƒƒã‚¯ã‚¹å¾æœãƒã‚§ãƒƒã‚¯
              if (
                dist < 10 &&
                next.owner !== "_SEA" &&
                next.owner !== u.tag &&
                this.isWar(u.tag, next.owner) &&
                !this.isAlly(u.tag, next.owner)
              ) {
                if (u.org > 5) this.conquerHex(u, next);
              }

              // ç§»å‹•å®Ÿè¡Œ
              if (dist <= spd || isNaN(dist)) {
                this.removeFromGrid(u, u.hex);
                u.x = next.x;
                u.y = next.y;
                u.hex = next;
                u.path.shift();
                this.addToGrid(u, next);

                if (
                  u.hex.owner !== "_SEA" &&
                  u.hex.owner !== u.tag &&
                  this.isWar(u.tag, u.hex.owner) &&
                  !this.isAlly(u.tag, u.hex.owner)
                ) {
                  if (u.org > 5) this.conquerHex(u, u.hex);
                }

                if (u.path.length === 0) u.state = "idle";
              } else {
                u.x += (dx / dist) * spd;
                u.y += (dy / dist) * spd;
              }
            } else {
              // å¾…æ©Ÿä¸­ã®å›å¾©
              if (u.isFighting && u.innerEl) {
                u.innerEl.classList.remove("fighting");
                u.isFighting = false;
              }

              if (u.org < u.maxOrg) {
                u.org += 0.8 * Math.max(0.1, u.supply / 100);
                if (u.org > u.maxOrg) u.org = u.maxOrg;
              }
            }

            // æç”»æ›´æ–°
            Renderer.updateUnit(u);
          }

          // 3. ãƒ¦ãƒ‹ãƒƒãƒˆã‚°ãƒªãƒƒãƒ‰ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          if (this.day % 100 === 0) {
            this.cleanupUnitGrid();
          }
        },
        updateOffscreenUnit: function (u) {
          // ç”»é¢å¤–ãƒ¦ãƒ‹ãƒƒãƒˆç”¨ã®ç°¡æ˜“æ›´æ–°
          if (u.state === "moving" && u.path.length > 0) {
            const next = u.path[0];

            // æ•µãŒã„ãªã„ã‹ç°¡æ˜“ãƒã‚§ãƒƒã‚¯
            let hasEnemy = false;
            if (u.hex) {
              const unitsInHex = this.unitGrid.get(u.hex.id);
              if (unitsInHex) {
                for (let unit of unitsInHex) {
                  if (unit.tag !== u.tag && this.isWar(unit.tag, u.tag)) {
                    hasEnemy = true;
                    break;
                  }
                }
              }
            }

            if (!hasEnemy) {
              // ç°¡æ˜“ç§»å‹•ï¼ˆç›´æ¥ãƒ†ãƒ¬ãƒãƒ¼ãƒˆï¼‰
              this.removeFromGrid(u, u.hex);
              u.x = next.x;
              u.y = next.y;
              u.hex = next;
              u.path.shift();
              this.addToGrid(u, next);

              if (u.path.length === 0) {
                u.state = "idle";
              }

              // å¾æœãƒã‚§ãƒƒã‚¯ï¼ˆç°¡æ˜“ç‰ˆï¼‰
              if (
                next.owner !== "_SEA" &&
                next.owner !== u.tag &&
                this.isWar(u.tag, next.owner) &&
                !this.isAlly(u.tag, next.owner)
              ) {
                if (u.org > 5) {
                  // ç°¡æ˜“å¾æœï¼ˆé…å»¶å®Ÿè¡Œï¼‰
                  setTimeout(() => {
                    if (u.hp > 0) this.conquerHex(u, next);
                  }, 100);
                }
              }
            }
          }

          // è£œçµ¦ã¨å›å¾©ï¼ˆç°¡æ˜“ç‰ˆï¼‰
          if (u.supply < 100) u.supply += 1;
          if (u.org < u.maxOrg) u.org += 0.5;
        },
        recruit: function () {
          const c = this.countries[this.player];
          const stats = this.calcStats(c.template);
          const armySize = this.units.filter(
            (u) => u.tag === this.player
          ).length;
          const maxArmy = Math.min(~~(c.fac * 1.5 + 2), 50);
          if (armySize >= maxArmy) {
            UI.notify(`å¸«å›£ä¸Šé™ã§ã™ (ç¾åœ¨:${armySize}/${maxArmy})`, "warn");
            return;
          }
          const actualEqCost = stats.cost;
          if (c.mp >= 1000 && c.eq >= actualEqCost) {
            c.mp -= 1000;
            c.eq -= actualEqCost;
            if (c.provs.length) {
              this.spawnUnit(this.player, c.capital, c.template);
              UI.notify("å¸«å›£ç·¨æˆå®Œäº†");
            }
          } else {
            UI.notify(
              `è³‡æºä¸è¶³ (å¿…è¦: äººçš„1000, è£…å‚™${actualEqCost.toFixed(0)})`,
              "warn"
            );
          }
        },
        buildFactory: function () {
          const c = this.countries[this.player];
          if (c.focus) {
            UI.notify("å›½å®¶æ–¹é‡å®Ÿè¡Œä¸­ã¯å·¥å ´ã‚’å»ºè¨­ã§ãã¾ã›ã‚“ã€‚", "warn");
            return;
          }
          if (c.buildingFactory) {
            UI.notify("æ—¢ã«å·¥å ´ã‚’å»ºè¨­ä¸­ã§ã™ã€‚", "warn");
            return;
          }
          if (c.pp < 50) {
            UI.notify("æ”¿æ²»åŠ›ãŒè¶³ã‚Šã¾ã›ã‚“ (50å¿…è¦)ã€‚", "warn");
            return;
          }
          c.pp -= 50;
          c.buildingFactory = { cost: 10, progress: 0, name: "çœŒå–¶å·¥å ´å»ºè¨­" };
          UI.notify("çœŒå–¶å·¥å ´ã®å»ºè¨­ã‚’é–‹å§‹ã—ã¾ã—ãŸ", "success");
          UI.update();
        },
        calcCapitals: function () {
          Object.values(this.countries).forEach((c) => {
            if (c.tag === "_SEA") return;
            if (c.provs.length === 0) {
              if (c.capIcon) {
                c.capIcon.remove();
                c.capIcon = null;
              }
              c.capital = null;
              return;
            }
            if (c.capital && c.provs.includes(c.capital)) {
              if (!c.capIcon) {
                const t = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "text"
                );
                t.textContent = "â˜…";
                t.setAttribute("fill", "gold");
                t.setAttribute(
                  "style",
                  "pointer-events:none;font-size:18px;font-weight:bold;text-shadow:0 0 2px #000"
                );
                $("game-svg").appendChild(t);
                c.capIcon = t;
              }
              c.capIcon.setAttribute("x", c.capital.x - 9);
              c.capIcon.setAttribute("y", c.capital.y + 6);
              return;
            }
            let best = c.provs[0];
            const fixed =
              CapitalCoords[c.tag] ||
              (c.name.includes("Tokyo") ? CapitalCoords["P13"] : null);
            if (fixed) {
              let minD = Infinity;
              c.provs.forEach((p) => {
                const d = (p.lat - fixed.lat) ** 2 + (p.lon - fixed.lon) ** 2;
                if (d < minD) {
                  minD = d;
                  best = p;
                }
              });
            } else {
              let cx = 0,
                cy = 0;
              c.provs.forEach((p) => {
                cx += p.gx;
                cy += p.gy;
              });
              cx /= c.provs.length;
              cy /= c.provs.length;
              let minD = Infinity;
              c.provs.forEach((p) => {
                const d = (p.gx - cx) ** 2 + (p.gy - cy) ** 2;
                if (d < minD) {
                  minD = d;
                  best = p;
                }
              });
            }
            c.capital = best;
            if (!c.capIcon) {
              const t = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              t.textContent = "â˜…";
              t.setAttribute("fill", "gold");
              t.setAttribute(
                "style",
                "pointer-events:none;font-size:18px;font-weight:bold;text-shadow:0 0 2px #000"
              );
              $("game-svg").appendChild(t);
              c.capIcon = t;
            }
            c.capIcon.setAttribute("x", best.x - 9);
            c.capIcon.setAttribute("y", best.y + 6);
          });
        },
        conquerHex: function (u, h) {
          const oldOwner = h.owner;
          if (oldOwner === u.tag) return;
          const oc = this.countries[oldOwner];
          const nc = this.countries[u.tag];
          if (h.factories > 0) {
            nc.fac += h.factories;
            if (oc) oc.fac -= h.factories;
          }
          if (oc) oc.provs = oc.provs.filter((x) => x !== h);
          h.owner = u.tag;
          h.el.setAttribute("fill", nc.col);
          nc.provs.push(h);
          if (oc && oc.capital === h) {
            UI.notify(`${nc.name} ãŒ ${oc.name} ã®çœŒåºæ‰€åœ¨åœ°ã‚’åˆ¶åœ§ï¼`, "war");
            oc.ws -= 50;
            if (oc.ws < 20) {
              this.capitulate(oldOwner, u.tag);
            } else {
              this.calcCapitals();
            }
          } else {
            this.calcCapitals();
          }
          this.calcSupplyAll();
        },
        capitulate: function (loser, winner) {
          const lc = this.countries[loser];
          const wc = this.countries[winner];
          SuperEvent.trigger(
            "çœŒåºé™¥è½",
            `${lc.name} æ”¿åºœãŒé™ä¼ã€‚\nå…¨åœŸã¯ ${wc.name} ã®çœŒæ”¿ä¸‹ã«ç½®ã‹ã‚Œã‚‹ã€‚`,
            "ãƒ‹ãƒ¥ãƒ¼ã‚¹é€Ÿå ±",
            "ğŸ³ï¸",
            lc.col,
            "è«¸è¡Œç„¡å¸¸ã€‚"
          );
          [...lc.provs].forEach((p) => {
            p.owner = winner;
            p.el.setAttribute("fill", wc.col);
            wc.provs.push(p);
            wc.fac += p.factories;
          });
          lc.fac = 0;
          lc.provs = [];
          lc.dead = true;
          this.units = this.units.filter((u) => u.tag !== loser);
          document.querySelectorAll(".unit-grp").forEach((el) => {
            const uObj = this.units.find((x) => x.el === el);
            if (!uObj) el.remove();
          });
          this.unitGrid.forEach((v, k) => {
            this.unitGrid.set(
              k,
              v.filter((u) => u.tag !== loser)
            );
          });
          this.wars = this.wars.filter(
            (w) => w.atk !== loser && w.def !== loser
          );
          this.calcCapitals();
          this.calcSupplyAll();
        },
        declareWar: function (a, b) {
          if (this.isWar(a, b) || this.isAlly(a, b)) return;
          this.wars.push({ atk: a, def: b });
          this.tension += 2;
          if (this.countries[a]) this.countries[a].peaceTimer = 0;
          if (this.countries[b]) this.countries[b].peaceTimer = 0;

          const isPlayerInvolved = a === this.player || b === this.player;
          const isMajorWar =
            this.countries[a].fac >= 10 && this.countries[b].fac >= 10;

          if (isPlayerInvolved || isMajorWar) {
            UI.notify(
              `${this.countries[a].name} ãŒ ${this.countries[b].name} ã«å®£æˆ¦å¸ƒå‘Šï¼`,
              "war"
            );
          }

          if (
            this.tension > 80 &&
            this.day - this.lastSuperEventDay > 365 &&
            (isPlayerInvolved || isMajorWar)
          ) {
            const enemy = a === this.player ? b : a;
            const cName = this.countries[enemy].name;
            const title = "æˆ¦å›½æ™‚ä»£ å‹ƒç™º";
            const quote =
              "ã‚µã‚¤ã¯æŠ•ã’ã‚‰ã‚ŒãŸã€‚\nå¹³å’Œæ†²æ³•ã¯éå»ã®ã‚‚ã®ã¨ãªã‚Šã€åˆ—å³¶ã¯å†ã³ç‚ã«åŒ…ã¾ã‚Œã‚‹ã€‚";
            SuperEvent.trigger(
              title,
              quote,
              `${cName} çœŒçŸ¥äº‹å£°æ˜`,
              "âš”ï¸",
              "#200",
              "ã„ã–ã€å‡ºé™£ã€‚"
            );
            this.lastSuperEventDay = this.day;
          }

          if (Game.selected === b) UI.updateSidebar();
        },
        isWar: function (a, b) {
          return this.wars.some(
            (w) => (w.atk === a && w.def === b) || (w.atk === b && w.def === a)
          );
        },
        isAlly: function (tag1, tag2) {
          if (!this.countries[tag1] || !this.countries[tag2]) return false;
          const f1 = this.countries[tag1].faction;
          const f2 = this.countries[tag2].faction;
          return f1 && f2 && f1 === f2;
        },
        getAliveCountryCount: function () {
          return Object.keys(this.countries).filter(
            (k) => k !== "_SEA" && !this.countries[k].dead
          ).length;
        },
        justifyWar: function () {
          if (this.selected && this.selected !== this.player) {
            UI.notify("å·¥ä½œå“¡ã‚’æ´¾é£ä¸­...(æ­£å½“åŒ–)");
            setTimeout(() => this.declareWar(this.player, this.selected), 2000);
          }
        },
        startFocus: function (fid) {
          const c = this.countries[this.player];
          if (c.buildingFactory) {
            UI.notify("å»ºè¨­ä¸­ã¯çœŒæ”¿æ–¹é‡ã‚’é–‹å§‹ã§ãã¾ã›ã‚“ã€‚", "warn");
            return;
          }
          const tree = DB.FocusTree.GENERIC;
          const f = tree.find((x) => x.id === fid);
          if (f && c.pp >= f.cost) {
            c.focus = f;
            c.focusProg = 0;
            UI.updateFocusModal();
          }
        },
        completeFocus: function (c) {
          c.focus.eff(c);
          c.completedFocuses.push(c.focus.id);
          if (c.tag === this.player) {
            UI.notify(`${c.focus.t} å®Œäº†`, "success");
            UI.closeFocusTree();
          }
          c.focus = null;
        },
        setSpeed: function (s) {
          this.speed = s;
          this.running = s > 0;
          // ãƒ†ã‚£ãƒƒã‚¯æ•°ã‚’åŠæ¸›ã€‚æœ€å¤§é€Ÿåº¦ã§1ç§’ã‚ãŸã‚Š25ãƒ†ã‚£ãƒƒã‚¯ã€‚
          this.tickInterval = s === 0 ? Infinity : 1000 / (s * 5);
          document
            .querySelectorAll(".spd-btn")
            .forEach((b, i) =>
              b.classList.toggle("active", [0, 1, 3, 5].indexOf(s) === i)
            );
        },
        getNeighbors: function (tag) {
          const c = this.countries[tag];
          if (!c) return [];
          const neighbors = new Set();
          c.provs.forEach((p) => {
            p.adj.forEach((a) => {
              if (a.owner !== "_SEA" && a.owner !== tag) neighbors.add(a.owner);
            });
          });
          return Array.from(neighbors);
        },
        getFrontlineHexes: function (tag) {
          const c = this.countries[tag];
          if (!c) return [];
          return c.provs.filter((p) =>
            p.adj.some(
              (a) =>
                a.owner !== "_SEA" &&
                a.owner !== tag &&
                this.isWar(tag, a.owner)
            )
          );
        },
        initMap: function () {
          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg"
          );
          svg.id = "game-svg";
          svg.setAttribute("width", "100%");
          svg.setAttribute("height", "100%");
          svg.setAttribute("overflow", "visible");
          svg.style.transformOrigin = "0 0";
          svg.style.willChange = "transform";
          const defs = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "defs"
          );
          defs.innerHTML =
            '<filter id="glow"><feGaussianBlur stdDeviation="2" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
          svg.appendChild(defs);
          Input.mapWrapEl.appendChild(svg);

          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          this.geoData.features.forEach((f) => {
            f.geometry.coordinates.forEach((poly) => {
              const rings = f.geometry.type === "MultiPolygon" ? poly : [poly];
              rings.forEach((ring) => {
                const arr = f.geometry.type === "MultiPolygon" ? ring : rings;
                const points = Array.isArray(arr[0][0]) ? arr.flat() : arr;
                points.forEach((p) => {
                  const x = p[0];
                  const y = p[1];
                  if (x < minX) minX = x;
                  if (x > maxX) maxX = x;
                  if (y < minY) minY = y;
                  if (y > maxY) maxY = y;
                });
              });
            });
          });
          minX -= 1;
          maxX += 1;
          minY -= 1;
          maxY += 1;
          const mapScale = 120;
          const R = 22;
          const mapPixelWidth = (maxX - minX) * mapScale * 1.5;
          const mapPixelHeight = (maxY - minY) * mapScale * 1.8;
          const cols = Math.ceil(mapPixelWidth / (R * 1.5));
          const rows = Math.ceil(mapPixelHeight / (R * 1.732));

          MapSys.hexes = [];
          const isInside = (point, vs) => {
            let x = point[0],
              y = point[1];
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
              let xi = vs[i][0],
                yi = vs[i][1];
              let xj = vs[j][0],
                yj = vs[j][1];
              let intersect =
                yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
              if (intersect) inside = !inside;
            }
            return inside;
          };

          // GeoJSONãƒ•ã‚£ãƒ¼ãƒãƒ£ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’äº‹å‰ã«è¨ˆç®—
          const featureBBoxes = this.geoData.features.map((f) => {
            let minLon = Infinity,
              minLat = Infinity,
              maxLon = -Infinity,
              maxLat = -Infinity;
            const processCoords = (coords) => {
              coords.forEach((p) => {
                const lon = p[0];
                const lat = p[1];
                minLon = Math.min(minLon, lon);
                minLat = Math.min(minLat, lat);
                maxLon = Math.max(maxLon, lon);
                maxLat = Math.max(maxLat, lat);
              });
            };

            const polyType = f.geometry.type;
            const coords = f.geometry.coordinates;
            if (polyType === "Polygon") {
              coords.forEach((ring) => processCoords(ring));
            } else if (polyType === "MultiPolygon") {
              coords.forEach((poly) =>
                poly.forEach((ring) => processCoords(ring))
              );
            }
            return { feature: f, bbox: { minLon, minLat, maxLon, maxLat } };
          });

          for (let gy = 0; gy < rows; gy++) {
            for (let gx = 0; gx < cols; gx++) {
              const x = gx * R * 1.5 + 25;
              const y = gy * R * 1.732 + 25 + (gx % 2 ? R * 0.866 : 0);
              const lon = x / (mapScale * 1.5) + minX;
              const lat = maxY - y / (mapScale * 1.8);
              let owner = "_SEA";

              // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
              for (const fb of featureBBoxes) {
                const bbox = fb.bbox;
                if (
                  lon >= bbox.minLon &&
                  lon <= bbox.maxLon &&
                  lat >= bbox.minLat &&
                  lat <= bbox.maxLat
                ) {
                  let inside = false;
                  const f = fb.feature;
                  const props = f.properties;
                  const polyType = f.geometry.type;
                  const coords = f.geometry.coordinates;
                  if (polyType === "Polygon") {
                    coords.forEach((ring) => {
                      if (isInside([lon, lat], ring)) inside = true;
                    });
                  } else if (polyType === "MultiPolygon") {
                    coords.forEach((poly) => {
                      poly.forEach((ring) => {
                        if (isInside([lon, lat], ring)) inside = true;
                      });
                    });
                  }
                  if (inside) {
                    const name = props.nam_ja || props.nam;
                    const id = props.id
                      ? "P" + props.id
                      : name.replace(/[^a-zA-Z0-9]/g, "");
                    owner = id;
                    break;
                  }
                }
              }

              const hexEl = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "polygon"
              );
              const points = [];
              for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                points.push(
                  `${x + R * Math.cos(angle)},${y + R * Math.sin(angle)}`
                );
              }
              hexEl.setAttribute("points", points.join(" "));
              hexEl.setAttribute("class", owner === "_SEA" ? "hex sea" : "hex");
              hexEl.dataset.id = MapSys.hexes.length;

              if (owner !== "_SEA") {
                const c = this.countries[owner];
                if (c) {
                  hexEl.setAttribute("fill", c.col);
                  this.countries[owner].provs.push({
                    id: MapSys.hexes.length,
                    gx,
                    gy,
                    x,
                    y,
                    lon,
                    lat,
                    el: hexEl,
                    adj: [],
                    owner: owner,
                    type: "plains",
                    factories: 0,
                  });
                  const h =
                    this.countries[owner].provs[
                      this.countries[owner].provs.length - 1
                    ];
                  MapSys.hexes.push(h);
                  svg.appendChild(hexEl);
                  if (Math.random() < 0.05) {
                    h.factories = 1;
                    c.fac++;
                  }
                }
              } else {
                svg.appendChild(hexEl);
                MapSys.hexes.push({
                  id: MapSys.hexes.length,
                  gx,
                  gy,
                  x,
                  y,
                  lon,
                  lat,
                  el: hexEl,
                  adj: [],
                  owner: "_SEA",
                  type: "sea",
                  factories: 0,
                });
              }
            }
          }
          const gridMap = {};
          MapSys.hexes.forEach((h) => (gridMap[`${h.gx},${h.gy}`] = h));
          MapSys.hexes.forEach((a) => {
            const isOdd = a.gx % 2 === 1;
            const offsets = isOdd
              ? [
                  [0, -1],
                  [0, 1],
                  [-1, 0],
                  [-1, 1],
                  [1, 0],
                  [1, 1],
                ]
              : [
                  [0, -1],
                  [0, 1],
                  [-1, -1],
                  [-1, 0],
                  [1, -1],
                  [1, 0],
                ];
            offsets.forEach((o) => {
              const k = `${a.gx + o[0]},${a.gy + o[1]}`;
              if (gridMap[k]) a.adj.push(gridMap[k]);
            });
          });
          Renderer.layer = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );
          svg.appendChild(Renderer.layer);
          Renderer.uiLayer = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );
          svg.appendChild(Renderer.uiLayer);

          // çŸ¢å°ãƒãƒ¼ã‚«ãƒ¼ã®å®šç¾©
          if (!document.getElementById("arrowhead")) {
            const defs = $("game-svg").querySelector("defs");
            const marker = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "marker"
            );
            marker.setAttribute("id", "arrowhead");
            marker.setAttribute("markerWidth", "10");
            marker.setAttribute("markerHeight", "7");
            marker.setAttribute("refX", "9");
            marker.setAttribute("refY", "3.5");
            marker.setAttribute("orient", "auto");
            marker.innerHTML =
              '<polygon points="0 0, 10 3.5, 0 7" fill="#ffca28" />';
            defs.appendChild(marker);
          }

          this.calcCapitals();
          Renderer.s = 0.6;
          const screenCX = Input.mapWrapEl.offsetWidth / 2;
          const screenCY = Input.mapWrapEl.offsetHeight / 2;
          Renderer.x = screenCX - 800 * Renderer.s;
          Renderer.y = screenCY - 600 * Renderer.s;
          Renderer.update();
        },
      };
      const AI = {
        runCountry: function (tag) {
          const c = Game.countries[tag];
          if (!c || c.provs.length === 0 || c.dead) return;

          // å†…æ”¿AI: å›½å®¶æ–¹é‡ã®é¸æŠ
          if (!c.focus && !c.buildingFactory) {
            const tree = DB.FocusTree.GENERIC;
            const available = tree.filter(
              (f) =>
                !c.completedFocuses.includes(f.id) &&
                f.req.every((r) => c.completedFocuses.includes(r)) &&
                (!f.mut ||
                  !f.mut.some((m) => c.completedFocuses.includes(m))) &&
                (!f.cond || f.cond(c))
            );
            if (available.length > 0) {
              c.focus = available[Math.floor(Math.random() * available.length)];
              c.focusProg = 0;
            } else if (c.pp >= 70 && Math.random() < 0.2) {
              c.pp -= 50;
              c.buildingFactory = {
                cost: 10,
                progress: 0,
                name: "çœŒå–¶å·¥å ´å»ºè¨­",
              };
            }
          }

          const enemies = Game.wars
            .filter((w) => w.atk === tag || w.def === tag)
            .map((w) => (w.atk === tag ? w.def : w.atk));
          const myUnits = Game.units.filter((u) => u.tag === tag);
          const armyLimit = Math.min(~~(c.fac * 2 + 5), 80);
          if (
            c.mp > 2000 &&
            myUnits.length < armyLimit &&
            (enemies.length > 0 || Math.random() < 0.05)
          ) {
            let targetTmpl = DB.AITemplates.basic_inf;
            const roll = Math.random();
            if (c.fac >= 15) {
              if (roll < 0.3) targetTmpl = DB.AITemplates.tank_div;
              else if (roll < 0.5) targetTmpl = DB.AITemplates.mech_div;
              else if (roll < 0.7) targetTmpl = DB.AITemplates.mot_div;
              else targetTmpl = DB.AITemplates.strong_inf;
            } else if (c.fac >= 8) {
              if (roll < 0.15) targetTmpl = DB.AITemplates.tank_div;
              else if (roll < 0.4) targetTmpl = DB.AITemplates.bike_div;
              else targetTmpl = DB.AITemplates.strong_inf;
            } else {
              if (roll < 0.3) targetTmpl = DB.AITemplates.bike_div;
              else targetTmpl = DB.AITemplates.basic_inf;
            }
            const stats = Game.calcStats(targetTmpl);
            if (c.eq >= stats.cost) {
              c.mp -= 1000;
              c.eq -= stats.cost;
              Game.spawnUnit(tag, c.capital, targetTmpl);
            }
          }

          const plannedMoves = new Set();
          myUnits.forEach((u) => {
            if (u.state === "moving" && u.path.length > 0)
              plannedMoves.add(u.path[u.path.length - 1].id);
          });
          const idleUnits = myUnits
            .filter((u) => u.state === "idle" && u.org > 20)
            .sort(() => Math.random() - 0.5);
          const frontline = Game.getFrontlineHexes(tag);
          let actions = 0;
          const APM = 15;

          // === æˆ¦è¡“AIå¼·åŒ–: ã‚¢ãƒ³ãƒæˆ¦è¡“åˆ†æ ===
          let currentStrategy = "NORMAL";
          if (enemies.length > 0) {
            // æ•µã®çªå‡ºéƒ¨ï¼ˆBlitzï¼‰ã‚’æ¤œçŸ¥
            const dangerDist = 150;
            if (c.capital) {
              const threat = Game.units.find(
                (u) =>
                  u.tag !== tag &&
                  Game.isWar(tag, u.tag) &&
                  (u.template.bat.includes("tank") ||
                    u.template.bat.includes("mech")) &&
                  Math.hypot(u.x - c.capital.x, u.y - c.capital.y) < dangerDist
              );
              if (threat) currentStrategy = "COUNTER_BLITZ";
            }
          }

          for (let u of idleUnits) {
            if (actions >= APM) break;

            // 1. åŒ…å›²å›é¿ãƒ»æ’¤é€€ (Anti-Encirclement)
            // å‘¨å›²ã®æ•µå¯¾çš„ã‚¿ã‚¤ãƒ«æ•°ã‚’ç¢ºèª
            let hostileCount = 0;
            u.hex.adj.forEach((n) => {
              if (
                n.owner !== tag &&
                n.owner !== "_SEA" &&
                Game.isWar(tag, n.owner)
              )
                hostileCount++;
            });

            // 3æ–¹å‘ä»¥ä¸Šå›²ã¾ã‚Œã¦ã„ã‚‹ã‹ã€è£œçµ¦ä¸è¶³ãªã‚‰æ’¤é€€
            if (hostileCount >= 3 || u.org < 20 || u.supply < 20) {
              if (c.capital) {
                // é¦–éƒ½ã¸å‘ã‹ã†ãƒ‘ã‚¹ã‚’æ¢ã™ï¼ˆå®‰å…¨åœ°å¸¯ã¸ã®é€€é¿ï¼‰
                const path = Input.findPath(u.hex, c.capital, tag);
                // è¿‘ã™ãã‚‹å ´åˆã¯å‹•ã‹ãªã„ï¼ˆãƒ‘ãƒ‹ãƒƒã‚¯é˜²æ­¢ï¼‰
                if (path && path.length > 1) {
                  u.path = path.slice(0, 3); // å°‘ã—ãšã¤ä¸‹ãŒã‚‹
                  u.state = "moving";
                  actions++;
                  continue;
                }
              }
            }

            // 2. æˆ¦è¡“æ±ºå®š
            let tactic = DB.Tactics.PUSH;

            if (currentStrategy === "COUNTER_BLITZ") {
              if (
                u.template.bat.includes("tank") ||
                u.template.bat.includes("mot")
              )
                tactic = DB.Tactics.ENCIRCLE;
              else tactic = DB.Tactics.HOLD;
            } else {
              if (
                u.template.bat.includes("tank") ||
                u.template.bat.includes("mech")
              )
                tactic = DB.Tactics.BLITZ;
              else if (
                u.template.bat.includes("bike") ||
                u.template.bat.includes("mot")
              )
                tactic = DB.Tactics.ENCIRCLE;
              else if (enemies.length > 0 && c.provs.length < 5)
                tactic = DB.Tactics.HOLD;
            }

            let bestTarget = null;
            let maxScore = -9999;

            if (tactic === DB.Tactics.BLITZ && enemies.length > 0) {
              const enemyTag = enemies[0];
              const enemyCap = Game.countries[enemyTag].capital;
              if (enemyCap) {
                const path = Input.findPath(u.hex, enemyCap, tag);
                if (path && path.length > 0) {
                  u.path = path.slice(0, 5);
                  u.state = "moving";
                  actions++;
                  plannedMoves.add(u.path[u.path.length - 1].id);
                  continue;
                }
              }
            }

            u.hex.adj.forEach((n) => {
              if (n.owner === "_SEA" || n.owner === tag) return;
              if (!Game.isWar(tag, n.owner)) return;
              let score = 0;
              if (plannedMoves.has(n.id)) score -= 200;
              const enemyUnit = Game.getEnemyInHex(n, tag);

              if (tactic === DB.Tactics.ENCIRCLE) {
                if (!enemyUnit) score += 300;
                else score -= 50;
              } else if (tactic === DB.Tactics.HOLD) {
                if (enemyUnit) score -= 100;
              } else {
                if (!enemyUnit) score += 100;
                else {
                  if (enemyUnit.org < 30) score += 50;
                  else if (u.org < 40) score -= 50;
                  else score += 10;
                }
              }
              if (score > maxScore) {
                maxScore = score;
                bestTarget = n;
              }
            });

            if (bestTarget && maxScore > 0) {
              u.path = [bestTarget];
              u.state = "moving";
              actions++;
              plannedMoves.add(bestTarget.id);
              continue;
            }

            if (frontline.length > 0 && Math.random() < 0.3) {
              const f = frontline[Math.floor(Math.random() * frontline.length)];
              const d = (u.x - f.x) ** 2 + (u.y - f.y) ** 2;
              if (d < 10000) {
                const path = Input.findPath(u.hex, f, tag);
                if (path && path.length) {
                  u.path = path.slice(0, 5);
                  u.state = "moving";
                  actions++;
                  plannedMoves.add(path[path.length - 1].id);
                }
              }
            }
          }

          if (enemies.length === 0) {
            const neighbors = Game.getNeighbors(tag);
            if (neighbors.length > 0) {
              if (
                c.peaceTimer > 300 &&
                Math.random() < 0.3 &&
                myUnits.length > 4
              ) {
                const target =
                  neighbors[Math.floor(Math.random() * neighbors.length)];
                Game.declareWar(tag, target);
              }
            }
          }
        },
      };

      document.addEventListener("DOMContentLoaded", () => Game.init());
    </script>
  </body>
</html>
