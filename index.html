<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape"
    />
    <title>éƒ½é“åºœçœŒWar: é›»æ’ƒæˆ¦å¼·åŒ–ç‰ˆ (Blitzkrieg)</title>
    <style>
      /* === å…¨ä½“è¨­å®š === */
      body {
        background: #080808;
        color: #e0e0e0;
        font-family: "Yu Gothic UI", "Meiryo", sans-serif;
        margin: 0;
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
      }

      /* === ãƒˆãƒƒãƒ—ãƒãƒ¼ === */
      #topbar {
        display: flex;
        height: 50px;
        background: #181818;
        border-bottom: 1px solid #333;
        align-items: center;
        padding: 0 15px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.9);
        z-index: 20;
        position: relative;
      }
      .flag {
        font-size: 28px;
        margin-right: 15px;
        cursor: pointer;
        transition: 0.2s;
        filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.5));
      }
      .res-grp {
        display: flex;
        gap: 15px;
        margin-right: 20px;
        border-right: 1px solid #444;
        padding-right: 20px;
      }
      @media (max-width: 768px) {
        .res-grp {
          gap: 8px;
          margin-right: 10px;
          padding-right: 10px;
        }
        .res span.val {
          display: none;
        }
        .res-grp:nth-child(3) {
          display: none;
        }
      }
      .res {
        display: flex;
        align-items: center;
        font-size: 13px;
        font-weight: bold;
      }
      .icon {
        width: 14px;
        height: 14px;
        display: inline-block;
        margin-right: 6px;
        border-radius: 3px;
        box-shadow: 0 1px 3px #000;
      }
      .date-box {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 5px;
        background: #222;
        padding: 3px 12px;
        border-radius: 20px;
        border: 1px solid #444;
        color: #fff;
        font-family: monospace;
      }
      .spd-btn {
        background: none;
        border: none;
        color: #666;
        cursor: pointer;
        font-weight: bold;
        padding: 5px 8px;
        transition: 0.2s;
        font-size: 16px;
      }
      .spd-btn.active {
        color: #fff;
        text-shadow: 0 0 5px var(--hl);
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
      }

      /* === ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ === */
      #game-layout {
        display: flex;
        height: calc(100vh - 50px);
      }
      #sidebar {
        width: 320px;
        background: #121212;
        border-right: 1px solid #333;
        display: flex;
        flex-direction: column;
        z-index: 10;
        box-shadow: 2px 0 15px rgba(0, 0, 0, 0.6);
        transition: transform 0.3s;
      }
      @media (max-width: 600px) {
        #sidebar {
          position: absolute;
          height: 100%;
          transform: translateX(-100%);
          width: 100%;
          max-width: 350px;
        }
        #sidebar.show {
          transform: translateX(0);
        }
      }
      .tabs {
        display: flex;
        height: 45px;
        background: #0e0e0e;
      }
      .tab {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: #666;
        border-bottom: 3px solid transparent;
        font-size: 14px;
        transition: 0.2s;
        font-weight: bold;
        padding: 10px;
      }
      .tab.active {
        color: #fff;
        border-bottom-color: var(--hl);
        background: #1e1e1e;
      }
      .view {
        padding: 20px;
        display: none;
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      .view.active {
        display: block;
      }

      /* === ãƒãƒƒãƒ—ã‚¨ãƒªã‚¢ === */
      #map-wrap {
        flex: 1;
        position: relative;
        overflow: hidden;
        background: #020508;
        cursor: grab;
        touch-action: none;
      }
      /* SVGã®æœ€é©åŒ– */
      #game-svg {
        will-change: transform;
        backface-visibility: hidden;
      }

      /* === ãƒ¦ãƒ‹ãƒƒãƒˆãƒ»UI === */
      .unit-grp {
        cursor: pointer;
        contain: layout style paint; /* ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æœ€é©åŒ– */
      }
      .unit-grp.selected .unit-box {
        stroke: #fff;
        stroke-width: 1.5;
        filter: drop-shadow(0 0 3px #fff);
      }
      .unit-box {
        width: 22px;
        height: 14px;
        fill: #333;
        stroke: #000;
        stroke-width: 1;
      }
      .unit-icon {
        font-size: 10px;
        fill: #fff;
        text-anchor: middle;
        pointer-events: none;
      }
      .unit-bar {
        fill: #00e676;
      }
      .unit-org-bar {
        fill: #ff9100;
      }
      .unit-inner.fighting .unit-box {
        stroke: #ff5252;
        stroke-width: 2px;
      }
      .no-supply-icon {
        font-size: 12px;
        fill: red;
        font-weight: bold;
        stroke: #000;
        stroke-width: 0.5px;
      }

      /* === ä½œæˆ¦è¨ˆç”»ãƒ©ã‚¤ãƒ³ === */
      .battle-line {
        fill: none;
        stroke: #ffca28;
        stroke-width: 4px;
        stroke-dasharray: 8, 6;
        stroke-linecap: round;
        stroke-linejoin: round;
        opacity: 0.9;
        pointer-events: none;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8));
        animation: dashAnimation 1s linear infinite;
      }
      @keyframes dashAnimation {
        to {
          stroke-dashoffset: -14;
        }
      }

      /* === ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ === */
      #super-event-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        z-index: 20000;
        display: none;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
        cursor: pointer;
      }
      .se-container {
        width: 650px;
        height: 480px;
        background: #000;
        border: 4px solid #888;
        position: relative;
        box-shadow: 0 0 80px rgba(255, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
        max-width: 90%;
        max-height: 80%;
        cursor: auto;
        pointer-events: auto;
      }
      .se-scanlines {
        position: absolute;
        inset: 0;
        background: repeating-linear-gradient(
          transparent 0px,
          transparent 2px,
          rgba(0, 0, 0, 0.6) 4px
        );
        pointer-events: none;
        opacity: 0.5;
        z-index: 5;
        animation: flicker 0.15s infinite;
      }
      @keyframes flicker {
        0% {
          opacity: 0.45;
        }
        50% {
          opacity: 0.55;
        }
        100% {
          opacity: 0.45;
        }
      }
      .se-image-area {
        height: 280px;
        background: #111;
        position: relative;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        border-bottom: 3px solid #fff;
      }
      .se-title-box {
        background: #000;
        color: #fff;
        padding: 10px 0;
        border-top: 3px solid #fff;
        border-bottom: 3px solid #fff;
        margin-top: -30px;
        z-index: 10;
        width: 90%;
        text-align: center;
        margin-left: 5%;
        position: relative;
        box-shadow: 0 0 20px #000;
      }
      .se-title {
        font-family: "MS Mincho", serif;
        font-size: 32px;
        font-weight: 900;
        letter-spacing: 4px;
        text-shadow: 0 0 15px #f00;
        color: #fff;
      }
      .se-quote-box {
        flex: 1;
        padding: 10px 30px;
        color: #fff;
        font-family: "MS Mincho", serif;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        background: #050505;
      }
      .se-quote {
        font-size: 16px;
        margin-bottom: 8px;
        color: #ccc;
        line-height: 1.4;
        font-style: italic;
      }
      .se-author {
        font-size: 12px;
        color: #666;
        align-self: flex-end;
      }
      .se-btn {
        width: 100%;
        padding: 15px;
        background: #ddd;
        color: #000;
        border: none;
        font-family: "MS Mincho", serif;
        font-weight: 900;
        font-size: 18px;
        cursor: pointer;
        transition: 0.2s;
        border-top: 3px solid #555;
        text-transform: uppercase;
      }
      .se-btn:hover {
        background: #fff;
        letter-spacing: 4px;
        color: #b71c1c;
      }

      /* === UIéƒ¨å“ === */
      .btn {
        width: 100%;
        padding: 12px;
        background: linear-gradient(to bottom, #3a3a3a, #252525);
        border: 1px solid #444;
        color: #fff;
        cursor: pointer;
        margin-bottom: 10px;
        border-radius: 2px;
        font-weight: bold;
        text-shadow: 0 1px 2px #000;
        box-shadow: 0 2px 0 #111;
        transition: 0.1s;
        font-size: 14px;
      }
      .btn:hover {
        filter: brightness(1.2);
      }
      .btn-green {
        background: linear-gradient(to bottom, #1b5e20, #003300);
        border-color: #002200;
        color: #81c784;
      }
      .btn-red {
        background: linear-gradient(to bottom, #b71c1c, #7f0000);
        border-color: #5f0000;
        color: #ffcdd2;
      }

      /* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€š */
      .modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 100;
        display: none;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
      }
      .modal-win {
        width: 95%;
        max-width: 1200px;
        height: 90%;
        max-height: 800px;
        background: #1a1a1a;
        border: 1px solid #444;
        display: flex;
        flex-direction: column;
        box-shadow: 0 20px 60px #000;
        border-radius: 4px;
        overflow: hidden;
      }
      .modal-head {
        padding: 10px 20px;
        background: #252525;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #333;
      }

      /* æŠ¼ã—ã‚„ã™ã„é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ */
      .close-btn-lg {
        background: #b71c1c;
        color: #fff;
        font-size: 24px;
        font-weight: bold;
        border: 1px solid #ff5252;
        border-radius: 5px;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
      }
      .close-btn-lg:active {
        transform: scale(0.95);
        background: #f00;
      }

      #focus-modal .modal-body {
        overflow: hidden;
        cursor: grab;
        background: #0a0a0a;
        touch-action: none;
        height: 100%;
      }
      #focus-canvas {
        width: 3000px;
        height: 2000px;
        position: relative;
        background-image: radial-gradient(#333 1px, transparent 1px);
        background-size: 30px 30px;
        transform-origin: 0 0;
      }
      .focus-node {
        position: absolute;
        width: 240px;
        min-height: 90px;
        padding: 12px;
        background: #1f1f1f;
        border: 2px solid #444;
        color: #ccc;
        font-size: 13px;
        cursor: pointer;
        text-align: center;
        z-index: 2;
        border-radius: 2px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.8);
        transition: 0.2s;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      .focus-node:hover {
        transform: scale(1.05);
        z-index: 10;
        border-color: #fff;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
      }
      .focus-node.completed {
        border-color: var(--hl);
        background: #00251a;
        color: #80cbc4;
      }
      .focus-node.available {
        border-color: var(--warn);
        background: #261e05;
        box-shadow: 0 0 10px rgba(253, 216, 53, 0.15);
      }
      .focus-node.locked {
        opacity: 0.4;
        filter: grayscale(1);
        pointer-events: none;
      }
      .focus-node.exclusive-locked {
        border-color: #b71c1c;
        opacity: 0.6;
        filter: grayscale(1);
        pointer-events: none;
        background: #200;
      }
      .focus-lines-svg {
        position: absolute;
        inset: 0;
        pointer-events: none;
        width: 100%;
        height: 100%;
      }

      /* ãƒ‡ã‚¶ã‚¤ãƒŠãƒ¼ï¼ˆã‚¹ãƒãƒ›å¯¾å¿œå¼·åŒ–ï¼‰ */
      .ds-layout {
        display: flex;
        height: 100%;
        overflow: hidden;
      }

      /* å·¦ãƒ‘ãƒãƒ«ï¼ˆãƒªã‚¹ãƒˆï¼‰ */
      .ds-panel {
        width: 250px;
        background: #222;
        border-right: 1px solid #444;
        padding: 15px;
        overflow-y: auto;
        flex-shrink: 0;
      }

      /* å³ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ï¼ˆã‚°ãƒªãƒƒãƒ‰ï¼‰ */
      .ds-main {
        flex: 1;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #181818;
        overflow-y: auto;
      }

      /* ãƒ¢ãƒã‚¤ãƒ«ãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–èª¿æ•´ */
      @media (max-width: 850px) {
        .ds-layout {
          flex-direction: row;
        }
        .ds-panel {
          width: 35%;
          padding: 10px;
        }
        .ds-main {
          padding: 10px;
          width: 65%;
        }
        .ds-grid {
          grid-template-columns: repeat(3, 1fr);
          gap: 5px;
          padding: 10px;
        }
        .slot {
          width: 45px;
          height: 45px;
          font-size: 18px;
        }
        .unit-opt {
          padding: 8px;
          font-size: 11px;
        }
        .unit-opt-icon {
          font-size: 14px;
        }

        /* çµ±è¨ˆæƒ…å ±ã®æ–‡å­—ã‚µã‚¤ã‚ºç¸®å° */
        #ds-stats-box {
          font-size: 11px !important;
        }
      }

      /* ã•ã‚‰ã«å°ã•ã„ç”»é¢ï¼ˆç¸¦æŒã¡ãªã©ï¼‰ */
      @media (max-width: 500px) {
        .ds-layout {
          flex-direction: column-reverse;
        } /* ã‚°ãƒªãƒƒãƒ‰ã‚’ä¸Šã« */
        .ds-panel {
          width: 100%;
          height: 40%;
          border-right: none;
          border-top: 1px solid #444;
        }
        .ds-main {
          width: 100%;
          height: 60%;
        }
      }

      .ds-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin-bottom: 20px;
        background: #252525;
        padding: 15px;
        border-radius: 5px;
        border: 1px solid #333;
      }
      .slot {
        width: 60px;
        height: 60px;
        background: #333;
        border: 1px dashed #555;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        position: relative;
        border-radius: 3px;
        transition: 0.1s;
      }
      .slot.filled {
        border-style: solid;
        border-color: var(--hl);
        background: #2b2b2b;
      }
      .unit-opt {
        padding: 10px;
        background: #333;
        border: 1px solid #444;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 5px;
        border-radius: 3px;
        transition: 0.1s;
      }
      .unit-opt:hover {
        background: #444;
        border-color: #666;
        transform: translateX(3px);
      }

      :root {
        --hl: #00acc1;
        --warn: #ffb300;
        --danger: #e53935;
        --good: #43a047;
      }
      #news-feed {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 300px;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 50;
      }
      @media (max-width: 600px) {
        #news-feed {
          width: 90%;
          right: 5%;
        }
      }
      .news {
        background: rgba(10, 10, 10, 0.95);
        color: #fff;
        padding: 12px 15px;
        border-left: 4px solid #aaa;
        font-size: 13px;
        border-radius: 2px;
        animation: slideIn 0.3s;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
      }
      @keyframes slideIn {
        from {
          transform: translateX(100%);
        }
        to {
          transform: translateX(0);
        }
      }

      #start-screen {
        position: fixed;
        inset: 0;
        background: #050505;
        z-index: 9000;
        display: none;
        flex-direction: column;
        align-items: center;
        padding: 50px;
      }
      .country-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 15px;
        width: 100%;
        max-width: 1200px;
        overflow-y: auto;
        padding-bottom: 50px;
      }
      .country-card {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 5px;
        padding: 15px;
        cursor: pointer;
        transition: 0.2s;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100px;
        justify-content: center;
      }
      .country-card:hover {
        background: #2a2a2a;
        border-color: var(--danger);
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(183, 28, 28, 0.3);
      }

      .sb-profile {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        background: #222;
        padding: 15px;
        border-radius: 5px;
        border: 1px solid #333;
      }
      .focus-btn-custom {
        position: relative;
        height: 60px;
        text-align: left;
        padding-left: 15px;
        background: #1f1f1f;
      }
      .focus-bar-bg {
        position: absolute;
        bottom: 0;
        left: 0;
        height: 4px;
        width: 100%;
        background: #111;
      }
      .focus-bar-progress {
        height: 100%;
        width: 0;
        background: var(--warn);
        transition: 0.2s;
      }

      #select-box {
        position: absolute;
        border: 1px solid #fff;
        background: rgba(255, 255, 255, 0.1);
        display: none;
        pointer-events: none;
        z-index: 10;
      }
      #loading-overlay {
        position: fixed;
        inset: 0;
        background: #000;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #fff;
      }
      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #333;
        border-top-color: var(--danger);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* ä½œæˆ¦ãƒœã‚¿ãƒ³ */
      #btn-plan-mode {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 60px;
        height: 60px;
        background: #333;
        border: 2px solid #555;
        border-radius: 50%;
        color: #fff;
        font-size: 24px;
        display: none; /* é¸æŠæ™‚ã®ã¿è¡¨ç¤º */
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.8);
        cursor: pointer;
        z-index: 900;
        transition: 0.2s;
      }
      #btn-plan-mode.active {
        background: var(--warn);
        color: #000;
        border-color: #fff;
        transform: scale(1.1);
        box-shadow: 0 0 15px var(--warn);
      }
    </style>
  </head>
  <body>
    <!-- ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ -->
    <div id="super-event-overlay" onclick="SuperEvent.close()">
      <div class="se-container" onclick="event.stopPropagation()">
        <div class="se-scanlines"></div>
        <div class="se-image-area" id="se-img-box">
          <div
            style="font-size: 120px; opacity: 0.3; filter: blur(3px)"
            id="se-icon"
          >
            âš ï¸
          </div>
          <div class="se-title-box">
            <div class="se-title" id="se-title">ä»¤å’Œã®æˆ¦å›½æ™‚ä»£ å‹ƒç™º</div>
          </div>
        </div>
        <div class="se-quote-box">
          <div class="se-quote" id="se-quote">
            ã€Œåœ°æ–¹è‡ªæ²»ã¯æ­»ã‚“ã ã€‚ã“ã‚Œã‚ˆã‚ŠåŠ›ã«ã‚ˆã‚‹çµ±æ²»ã‚’è¡Œã†ã€‚ã€
          </div>
          <div class="se-author" id="se-author">- å…¨å›½çŸ¥äº‹ä¼š ç·Šæ€¥å£°æ˜</div>
        </div>
        <button class="se-btn" onclick="SuperEvent.close()" id="se-btn-text">
          å…¨è»ã€é€²æ’ƒã›ã‚ˆã€‚
        </button>
      </div>
    </div>

    <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° -->
    <div id="loading-overlay">
      <div class="spinner"></div>
      <div id="loading-text">æ—¥æœ¬åˆ—å³¶ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
    </div>

    <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ -->
    <div id="start-screen">
      <div
        style="
          font-size: 36px;
          font-weight: bold;
          margin-bottom: 10px;
          color: var(--danger);
          text-align: center;
          letter-spacing: 2px;
          text-shadow: 0 0 10px #500;
        "
      >
        éƒ½é“åºœçœŒå¤§æˆ¦ (WW2 Mod)
      </div>
      <div style="color: #aaa; margin-bottom: 40px; text-align: center">
        æŒ‡æ®ã™ã‚‹éƒ½é“åºœçœŒã‚’é¸æŠã‚»ãƒ¨
      </div>
      <div id="country-list" class="country-grid"></div>
    </div>

    <div id="select-box"></div>

    <!-- ãƒˆãƒƒãƒ—ãƒãƒ¼ -->
    <div id="topbar">
      <div class="flag" onclick="UI.toggleSidebar()" id="player-flag">ğŸ³ï¸</div>
      <div class="res-grp">
        <div class="res" title="æ”¿æ²»åŠ›">
          <span class="icon" style="background: #8d6e63"></span
          ><span class="val" id="res-pp">0</span>
        </div>
        <div class="res" title="å®‰å®šåº¦">
          <span class="icon" style="background: #fbc02d"></span
          ><span class="val" id="res-st">0%</span>
        </div>
        <div class="res" title="æˆ¦äº‰å”åŠ›åº¦">
          <span class="icon" style="background: #d32f2f"></span
          ><span class="val" id="res-ws">0%</span>
        </div>
      </div>
      <div class="res-grp">
        <div class="res" title="çœŒæ°‘(äººçš„è³‡æº)">
          <span class="icon" style="background: #5d4037"></span
          ><span class="val" id="res-man">0</span>
        </div>
        <div class="res" title="è£…å‚™">
          <span class="icon" style="background: #ff9800"></span
          ><span class="val" id="res-eq">0</span>
        </div>
        <div class="res" title="é™¸è»çµŒé¨“å€¤">
          <span class="icon" style="background: #66bb6a"></span
          ><span class="val" id="res-xp">0</span>
        </div>
      </div>
      <div class="date-box">
        <button class="spd-btn" onclick="Game.setSpeed(0)">||</button>
        <button class="spd-btn" onclick="Game.setSpeed(1)">1</button>
        <button class="spd-btn" onclick="Game.setSpeed(3)">3</button>
        <button class="spd-btn" onclick="Game.setSpeed(5)">5</button>
        <div
          id="game-date"
          style="font-weight: bold; margin-left: 8px; font-size: 14px"
        >
          Day 1
        </div>
      </div>
    </div>

    <!-- ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ -->
    <div id="game-layout">
      <!-- ã‚µã‚¤ãƒ‰ãƒãƒ¼ -->
      <div id="sidebar">
        <div class="tabs">
          <div class="tab active" onclick="UI.tab('main')">çœŒæ”¿</div>
          <div class="tab" onclick="UI.tab('army')">è»äº‹</div>
          <div class="tab" onclick="UI.tab('diplo')">å¤–äº¤</div>
        </div>

        <!-- å›½å®¶ã‚¿ãƒ– -->
        <div id="v-main" class="view active">
          <div class="sb-profile">
            <div
              class="sb-portrait-wrapper"
              id="sb-portrait"
              style="font-size: 30px; margin-right: 10px"
            >
              ?
            </div>
            <div>
              <div style="font-weight: bold; font-size: 16px" id="sb-name">
                Country
              </div>
              <div style="font-size: 12px; color: #aaa" id="sb-ideology">
                ä¸å…š: çœŒæ°‘ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ
              </div>
            </div>
          </div>
          <button class="btn focus-btn-custom" onclick="UI.openFocusTree()">
            <span class="focus-caption">çœŒæ”¿æ–¹é‡</span><br />
            <span id="sb-focus-curr" class="focus-name">é¸æŠã—ã¦ãã ã•ã„</span>
            <div class="focus-bar-bg">
              <div id="sb-focus-bar" class="focus-bar-progress"></div>
            </div>
          </button>
          <button
            class="btn btn-green"
            style="margin-top: 10px"
            onclick="Game.buildFactory()"
          >
            <span style="font-size: 16px">çœŒå–¶å·¥å ´å»ºè¨­</span><br />
            <span style="font-size: 11px; font-weight: normal"
              >æ”¿æ²»åŠ›:50, å»ºè¨­æœŸé–“:10æ—¥</span
            >
          </button>
          <div style="margin-top: 20px; font-size: 13px; color: #aaa">
            <div>
              å…¨å›½ç·Šå¼µåº¦:
              <span
                id="val-wt"
                style="
                  color: var(--danger);
                  font-weight: bold;
                  text-shadow: 0 0 5px red;
                "
                >0%</span
              >
            </div>
            <div>å·¥å ´æ•°: <span id="res-fac" style="color: #fff">0</span></div>
          </div>
        </div>

        <!-- è»äº‹ã‚¿ãƒ– -->
        <div id="v-army" class="view">
          <div
            style="
              background: #222;
              padding: 10px;
              border-radius: 5px;
              margin-bottom: 15px;
              border: 1px solid #333;
            "
          >
            <div
              style="
                font-size: 12px;
                color: #aaa;
                margin-bottom: 8px;
                display: flex;
                justify-content: space-between;
              "
            >
              <span>ç¾åœ¨ã®å¸«å›£ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ</span>
              <span
                style="color: var(--hl); cursor: pointer"
                onclick="UI.openDesigner()"
                >[ç·¨é›†]</span
              >
            </div>
            <div
              id="army-tmpl-stats"
              style="
                font-size: 11px;
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 5px;
                color: #ddd;
              "
            ></div>
          </div>
          <button class="btn btn-green" onclick="Game.recruit()">
            <span style="font-size: 16px">çœŒå…µå¾´å‹Ÿ</span><br />
            <span style="font-size: 11px; font-weight: normal" id="recruit-cost"
              >äººçš„:1000 è£…å‚™:100</span
            >
          </button>
          <div
            style="
              margin-top: 20px;
              padding-top: 10px;
              border-top: 1px solid #333;
            "
          >
            <div class="focus-caption">
              é¸æŠä¸­ã®å¸«å›£:
              <span id="sel-count" style="color: var(--hl); font-weight: bold"
                >0</span
              >
            </div>
            <div class="focus-caption">
              ç·å¸«å›£æ•°: <span id="army-count">0</span>
            </div>
            <div class="focus-caption">
              æœ€å¤§å¸«å›£æ•°(1çœŒ): <span id="army-cap">50</span>
            </div>
          </div>
        </div>

        <!-- å¤–äº¤ã‚¿ãƒ– -->
        <div id="v-diplo" class="view">
          <div
            id="diplo-msg"
            style="
              padding: 40px 20px;
              text-align: center;
              color: #666;
              border: 2px dashed #333;
              border-radius: 10px;
            "
          >
            åœ°å›³ä¸Šã®çœŒã‚’<br />ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„
          </div>
          <div id="diplo-content" style="display: none">
            <h2 id="dp-name" style="color: var(--warn); margin: 0 0 10px 0">
              Country
            </h2>
            <div
              style="
                margin-bottom: 20px;
                padding: 10px;
                background: #222;
                border-radius: 5px;
              "
            >
              <div class="focus-caption">
                é™£å–¶: <span id="dp-faction" style="color: #fff">ãªã—</span>
              </div>
            </div>
            <div
              id="dp-war-status"
              style="
                color: var(--danger);
                font-weight: bold;
                margin-bottom: 15px;
                display: none;
                text-align: center;
                border: 1px solid var(--danger);
                padding: 5px;
                background: #200;
              "
            >
              âš¡ æŠ—äº‰çŠ¶æ…‹ âš¡
            </div>
            <button
              class="btn btn-red"
              id="btn-declare-war"
              onclick="Game.justifyWar()"
            >
              å®£æˆ¦å¸ƒå‘Šã®æ­£å½“åŒ–
            </button>
          </div>
        </div>
      </div>

      <!-- ãƒãƒƒãƒ— -->
      <div id="map-wrap">
        <div
          id="btn-plan-mode"
          onclick="Input.togglePlanMode()"
          title="ä½œæˆ¦ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿"
        >
          ğŸ–Šï¸
        </div>
        <div id="news-feed"></div>
      </div>
    </div>

    <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: å›½å®¶æ–¹é‡ -->
    <div id="focus-modal" class="modal">
      <div class="modal-win">
        <div class="modal-head">
          <span style="font-size: 18px; font-weight: bold; color: #ddd"
            >çœŒæ”¿æ–¹é‡ãƒ„ãƒªãƒ¼ (ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç§»å‹•)</span
          >
          <button class="close-btn-lg" onclick="UI.closeFocusTree()">Ã—</button>
        </div>
        <div class="modal-body" id="focus-scroll-area">
          <div id="focus-canvas">
            <svg id="focus-lines" class="focus-lines-svg"></svg>
            <div id="focus-nodes"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: å¸«å›£è¨­è¨ˆ -->
    <div id="design-modal" class="modal">
      <div class="modal-win">
        <div class="modal-head">
          <div style="display: flex; align-items: center; gap: 10px">
            <span style="font-size: 16px; font-weight: bold">å¸«å›£ç·¨æˆ</span>
            <span
              style="
                font-size: 12px;
                background: #444;
                padding: 2px 8px;
                border-radius: 10px;
              "
              >â˜… <span id="ds-xp">0</span> XP</span
            >
          </div>
          <button class="close-btn-lg" onclick="UI.closeDesigner()">Ã—</button>
        </div>
        <div class="ds-layout">
          <div class="ds-panel">
            <div
              style="
                font-size: 12px;
                color: #888;
                text-align: center;
                margin-bottom: 5px;
                font-weight: bold;
              "
            >
              æˆ¦é—˜å¤§éšŠ
            </div>
            <div id="opt-battalions"></div>
            <div
              style="
                font-size: 12px;
                color: #888;
                text-align: center;
                margin: 20px 0 5px 0;
                font-weight: bold;
              "
            >
              æ”¯æ´ä¸­éšŠ
            </div>
            <div id="opt-support"></div>
          </div>
          <div class="ds-main">
            <div style="width: 100%; max-width: 500px">
              <div class="ds-grid">
                <div
                  style="
                    grid-column: 1/-1;
                    font-size: 12px;
                    color: #888;
                    text-align: center;
                    margin-bottom: 5px;
                  "
                >
                  ä¸»åŠ›å¤§éšŠ (æœ€å¤§6)
                </div>
                <div id="grid-bat" style="display: contents"></div>
              </div>
              <div
                class="ds-grid"
                style="grid-template-columns: repeat(3, 1fr)"
              >
                <div
                  style="
                    grid-column: 1/-1;
                    font-size: 12px;
                    color: #888;
                    text-align: center;
                    margin-bottom: 5px;
                  "
                >
                  æ”¯æ´ä¸­éšŠ (æœ€å¤§3)
                </div>
                <div id="grid-sup" style="display: contents"></div>
              </div>
            </div>
            <div
              id="ds-stats-box"
              style="
                width: 100%;
                max-width: 500px;
                background: #222;
                padding: 10px;
                border-radius: 5px;
                margin-top: 10px;
                border: 1px solid #333;
                font-size: 13px;
              "
            >
              <div
                style="
                  font-size: 12px;
                  color: #aaa;
                  margin-bottom: 5px;
                  border-bottom: 1px solid #444;
                "
              >
                äºˆæ¸¬ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
              </div>
              <div
                style="
                  display: grid;
                  grid-template-columns: 1fr 1fr;
                  gap: 4px;
                  width: 100%;
                "
              >
                <div style="display: flex; justify-content: space-between">
                  <span>å¯¾äººæ”»æ’ƒ</span
                  ><span
                    style="font-weight: bold; color: var(--warn)"
                    id="ds-atk-s"
                    >0</span
                  >
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span>å¯¾ç”²æ”»æ’ƒ</span
                  ><span
                    style="font-weight: bold; color: var(--danger)"
                    id="ds-atk-h"
                    >0</span
                  >
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span>é˜²å¾¡</span
                  ><span style="font-weight: bold; color: #42a5f5" id="ds-def"
                    >0</span
                  >
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span>çªç ´</span
                  ><span style="font-weight: bold; color: #ce93d8" id="ds-brk"
                    >0</span
                  >
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span>è£…ç”²</span
                  ><span style="font-weight: bold; color: #bdbdbd" id="ds-arm"
                    >0</span
                  >
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span>ã‚³ã‚¹ãƒˆ</span
                  ><span style="font-weight: bold; color: #fff" id="ds-cost"
                    >0</span
                  >
                </div>
              </div>
            </div>
            <button
              class="btn btn-green"
              style="margin-top: 10px; width: 100%"
              onclick="Designer.save()"
            >
              ä¿å­˜ (ã‚³ã‚¹ãƒˆ: 10 XP)
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const $ = (id) => document.getElementById(id);
      const $c = (t, c) => {
        const e = document.createElement(t);
        if (c) e.className = c;
        return e;
      };
      const nFmt = (n) =>
        n >= 1e6
          ? (n / 1e6).toFixed(2) + "M"
          : n >= 1e3
          ? (n / 1e3).toFixed(1) + "K"
          : n;

      let colorHue = Math.random();
      const nextColor = () => {
        colorHue = (colorHue + 0.618033988749895) % 1;
        return `hsl(${Math.floor(colorHue * 360)}, 65%, 45%)`;
      };

      // ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
      const SuperEvent = {
        overlay: $("super-event-overlay"),
        title: $("se-title"),
        quote: $("se-quote"),
        author: $("se-author"),
        btnText: $("se-btn-text"),
        imgBox: $("se-img-box"),
        icon: $("se-icon"),
        history: [],
        trigger: function (title, quote, author, iconStr, color, btnText) {
          if (!this.overlay) return;
          if (this.history.includes(title)) return;

          this.title.innerText = title;
          this.quote.innerHTML = quote.replace(/\n/g, "<br>");
          this.author.innerText = "- " + author;
          this.icon.innerText = iconStr || "âš ï¸";
          this.btnText.innerText = btnText || "æˆ‘ã€…ãƒ‹é¸æŠè‚¢ãƒç„¡ã‚¤ã€‚";
          this.imgBox.style.background = color || "#333";
          this.overlay.style.display = "flex";

          this.history.push(title);
        },
        close: function () {
          if (this.overlay) this.overlay.style.display = "none";
        },
      };

      const DB = {
        UnitTypes: {
          inf: {
            name: "æ™®é€šç§‘",
            icon: "ğŸª–",
            type: "bat",
            sa: 25,
            ha: 5,
            def: 25,
            brk: 5,
            arm: 0,
            prc: 5,
            org: 60,
            spd: 4.0,
            cost: 300,
          },
          art: {
            name: "ç‰¹ç§‘",
            icon: "ğŸ’¥",
            type: "bat",
            sa: 60,
            ha: 10,
            def: 5,
            brk: 5,
            arm: 0,
            prc: 5,
            org: 10,
            spd: 3.5,
            cost: 700,
          },
          tank: {
            name: "æ©Ÿç”²ç§‘",
            icon: "ğŸšœ",
            type: "bat",
            sa: 40,
            ha: 50,
            def: 20,
            brk: 70,
            arm: 50,
            prc: 45,
            org: 30,
            spd: 8.0,
            cost: 3000,
          },
          mot: {
            name: "å³å¿œæ©Ÿå‹•",
            icon: "ğŸšš",
            type: "bat",
            sa: 22,
            ha: 5,
            def: 20,
            brk: 25,
            arm: 5,
            prc: 8,
            org: 55,
            spd: 12.0,
            cost: 1000,
          },
          mech: {
            name: "æ©Ÿæ¢°åŒ–",
            icon: "ğŸš™",
            type: "bat",
            sa: 30,
            ha: 20,
            def: 35,
            brk: 35,
            arm: 25,
            prc: 20,
            org: 50,
            spd: 10.0,
            cost: 1800,
          },
          bike: {
            name: "è‡ªè»¢è»Š",
            icon: "ğŸš²",
            type: "bat",
            sa: 20,
            ha: 3,
            def: 20,
            brk: 15,
            arm: 0,
            prc: 5,
            org: 55,
            spd: 9.0,
            cost: 400,
          },
          eng: {
            name: "æ–½è¨­ç§‘",
            icon: "ğŸ› ï¸",
            type: "sup",
            sa: 5,
            ha: 2,
            def: 25,
            brk: 5,
            arm: 0,
            prc: 5,
            org: 20,
            spd: 0,
            cost: 500,
          },
          rec: {
            name: "åµå¯Ÿ",
            icon: "ğŸ”­",
            type: "sup",
            sa: 4,
            ha: 1,
            def: 5,
            brk: 5,
            arm: 0,
            prc: 0,
            org: 10,
            spd: 1.1,
            cost: 400,
          },
          sup_art: {
            name: "æ”¯æ´ç«ç ²",
            icon: "ğŸ§¨",
            type: "sup",
            sa: 30,
            ha: 5,
            def: 5,
            brk: 10,
            arm: 0,
            prc: 5,
            org: 0,
            spd: 0,
            cost: 600,
          },
        },
        AITemplates: {
          basic_inf: { bat: ["inf", "inf", "inf", "inf"], sup: ["eng"] },
          strong_inf: {
            bat: ["inf", "inf", "inf", "art"],
            sup: ["eng", "sup_art"],
          },
          bike_div: { bat: ["bike", "bike", "bike", "bike"], sup: ["rec"] },
          mot_div: {
            bat: ["mot", "mot", "mot", "inf"],
            sup: ["eng", "sup_art"],
          }, // æ©Ÿå‹•æ­©å…µä¸­å¿ƒ
          mech_div: {
            bat: ["mech", "mech", "mech", "mot"],
            sup: ["eng", "rec"],
          }, // æ©Ÿæ¢°åŒ–æ­©å…µä¸­å¿ƒ
          tank_div: {
            bat: ["tank", "tank", "mot", "mot"],
            sup: ["eng", "sup_art"],
          }, // æˆ¦è»Šä¸­å¿ƒ
          elite_tank: {
            bat: ["tank", "tank", "tank", "mech", "mech"],
            sup: ["eng", "rec", "sup_art"],
          }, // ã‚¨ãƒªãƒ¼ãƒˆæˆ¦è»Š
        },
        FocusTree: { GENERIC: [] },
        Terrain: {
          sea: { name: "ç€¬æˆ¸å†…æµ·/æµ·", color: "#050a10", moveCost: 5 },
          plains: { name: "å¹³åœ°", color: "#3e4e38", moveCost: 1 },
        },
      };

      // --- Focus Tree Definitions ---
      const addFocus = (tree, id, x, y, t, d, cost, req, eff, mut, cond) => {
        tree.push({ id, x, y, t, d, cost, req, eff, mut, cond });
      };

      // 1. GENERIC (ã‚³ã‚¹ãƒˆ10å€: 700~)
      const FT_GEN = [];
      addFocus(
        FT_GEN,
        "g_ind",
        1400,
        100,
        "ç”£æ¥­é–‹ç™º",
        "å·¥å ´+1",
        700,
        [],
        (c) => (c.fac += 1)
      );
      addFocus(
        FT_GEN,
        "g_mil",
        1700,
        100,
        "è»æ‹¡",
        "XP+20",
        700,
        [],
        (c) => (c.xp += 20)
      );
      addFocus(
        FT_GEN,
        "g_pol",
        1100,
        100,
        "æ”¿æ²»åŠ›å¼·åŒ–",
        "PP+100",
        700,
        [],
        (c) => (c.pp += 100)
      );
      addFocus(
        FT_GEN,
        "g_inf",
        1400,
        300,
        "ã‚¤ãƒ³ãƒ•ãƒ©æ•´å‚™",
        "å·¥å ´+2, ç§»å‹•+5%",
        900,
        ["g_ind"],
        (c) => {
          c.fac += 2;
          c.speedBonus = (c.speedBonus || 0) + 0.05;
        }
      );
      addFocus(
        FT_GEN,
        "g_def",
        1700,
        300,
        "é˜²è¡›ãƒ‰ã‚¯ãƒˆãƒªãƒ³",
        "é˜²å¾¡+10%",
        900,
        ["g_mil"],
        (c) => (c.territoryDefBonus = (c.territoryDefBonus || 0) + 0.1)
      );
      addFocus(
        FT_GEN,
        "g_res",
        1100,
        300,
        "è³‡æºæ¢æŸ»",
        "è£…å‚™+2000",
        900,
        ["g_pol"],
        (c) => (c.eq += 2000)
      );
      addFocus(
        FT_GEN,
        "g_nuc",
        1400,
        500,
        "åŸå­åŠ›ç ”ç©¶",
        "ç ”ç©¶å®Œäº†(ãƒ•ãƒ¬ãƒ¼ãƒãƒ¼)",
        1500,
        ["g_inf"],
        (c) => {}
      );
      addFocus(
        FT_GEN,
        "g_mod",
        1700,
        500,
        "è¿‘ä»£åŒ–æ”¹ä¿®",
        "XP+50, è£…å‚™+5000",
        1200,
        ["g_def"],
        (c) => {
          c.xp += 50;
          c.eq += 5000;
        }
      );
      addFocus(
        FT_GEN,
        "g_sta",
        1100,
        500,
        "å®‰å®šåŒ–å·¥ä½œ",
        "å®‰å®š+10%",
        900,
        ["g_res"],
        (c) => (c.st += 10)
      );
      addFocus(
        FT_GEN,
        "g_fin",
        1400,
        700,
        "æœ€çµ‚é˜²è¡›ãƒ©ã‚¤ãƒ³",
        "é˜²å¾¡+20%",
        1500,
        ["g_nuc", "g_mod"],
        (c) => (c.territoryDefBonus += 0.2)
      );
      DB.FocusTree.GENERIC = FT_GEN;

      // 2. GENERIC_WAR (è¥¿æ—¥æœ¬/ä¹å·)
      const FT_WAR = [];
      addFocus(
        FT_WAR,
        "w_prep",
        1500,
        100,
        "é–‹æˆ¦æº–å‚™",
        "å·¥å ´+2, PP+50",
        700,
        [],
        (c) => {
          c.fac += 2;
          c.pp += 50;
        }
      );
      addFocus(
        FT_WAR,
        "w_mob",
        1500,
        250,
        "ç·å‹•å“¡",
        "äººçš„+20000",
        1000,
        ["w_prep"],
        (c) => (c.mp += 20000)
      );
      addFocus(
        FT_WAR,
        "w_uni",
        1500,
        400,
        "åœ°åŸŸçµ±ä¸€",
        "éš£å›½ã¸å®£æˆ¦",
        1400,
        ["w_mob"],
        (c) => {
          const neighbors = Game.getNeighbors(c.tag);
          const target = neighbors.find((n) => !Game.isAlly(c.tag, n));
          if (target) {
            UI.notify(
              `${c.name} ãŒåœ°åŸŸçµ±ä¸€ã®ãŸã‚ ${Game.countries[target].name} ã«å®£æˆ¦å¸ƒå‘Šï¼`,
              "war"
            );
            Game.declareWar(c.tag, target);
          }
        }
      );
      addFocus(
        FT_WAR,
        "w_exp",
        1500,
        550,
        "é ˜åœŸæ‹¡å¤§",
        "åˆ¥ã®éš£å›½ã¸å®£æˆ¦",
        1400,
        ["w_uni"],
        (c) => {
          const neighbors = Game.getNeighbors(c.tag);
          const target = neighbors.find(
            (n) => !Game.isAlly(c.tag, n) && !Game.isWar(c.tag, n)
          );
          if (target) Game.declareWar(c.tag, target);
        }
      );
      addFocus(
        FT_WAR,
        "w_ind",
        1300,
        250,
        "è»éœ€ç”£æ¥­",
        "å·¥å ´+3",
        1000,
        ["w_prep"],
        (c) => (c.fac += 3)
      );
      addFocus(
        FT_WAR,
        "w_doc",
        1700,
        250,
        "æ”»æ’ƒãƒ‰ã‚¯ãƒˆãƒªãƒ³",
        "çªç ´+10%",
        1000,
        ["w_prep"],
        (c) => {}
      );
      addFocus(
        FT_WAR,
        "w_hvy",
        1300,
        400,
        "é‡è£…å‚™åŒ–",
        "è£…å‚™+10000",
        1200,
        ["w_ind"],
        (c) => (c.eq += 10000)
      );
      addFocus(
        FT_WAR,
        "w_eli",
        1700,
        400,
        "ç²¾é‹­éƒ¨éšŠ",
        "XP+100",
        1200,
        ["w_doc"],
        (c) => (c.xp += 100)
      );
      addFocus(
        FT_WAR,
        "w_fin",
        1500,
        700,
        "è¦‡æ¨©ç¢ºç«‹",
        "å®‰å®š+20%, å·¥å ´+5",
        2000,
        ["w_exp"],
        (c) => {
          c.st += 20;
          c.fac += 5;
        }
      );
      DB.FocusTree.GENERIC_WAR = FT_WAR;

      // 3. GUNMA (Germany)
      const FT_GUN = [];
      addFocus(
        FT_GUN,
        "g_emp",
        1400,
        100,
        "å¸å›½ã®å¾©æ´»",
        "PP+200, å®‰å®š+20%",
        700,
        [],
        (c) => {
          c.pp += 200;
          c.st += 20;
        }
      );
      addFocus(
        FT_GUN,
        "g_ind",
        1200,
        250,
        "ãƒ‹ãƒ¥ãƒ¼ã‚¤ãƒ¤ãƒ¼é§…ä¼å¼·åŒ–",
        "å·¥å ´+10, ç§»å‹•+10%",
        1000,
        ["g_emp"],
        (c) => {
          c.fac += 10;
          c.speedBonus = 0.1;
        }
      );
      addFocus(
        FT_GUN,
        "g_army",
        1600,
        250,
        "èµ¤åŸãŠã‚ã—",
        "XP+200, è£…å‚™+10000",
        1000,
        ["g_emp"],
        (c) => {
          c.xp += 200;
          c.eq += 10000;
        }
      );

      addFocus(
        FT_GUN,
        "g_toch",
        1400,
        400,
        "åŒ—é–¢æ±ã®é‹å‘½",
        "æ ƒæœ¨ã¸å®£æˆ¦å¸ƒå‘Š",
        1500,
        ["g_emp"],
        (c) => {
          UI.notify("ã‚°ãƒ³ãƒãƒ¼å¸å›½ãŒæ ƒæœ¨ã®é ˜æœ‰ã‚’ä¸»å¼µã—ã€ä¾µæ”»é–‹å§‹ï¼", "war");
          let tTag = null;
          Object.keys(Game.countries).forEach((k) => {
            if (Game.countries[k].name.includes("æ ƒæœ¨")) tTag = k;
          });
          if (tTag) Game.declareWar(c.tag, tTag);
        }
      );
      addFocus(
        FT_GUN,
        "g_ibar",
        1400,
        550,
        "é–¢æ±ç”Ÿå­˜åœ",
        "èŒ¨åŸã¸å®£æˆ¦å¸ƒå‘Š",
        2000,
        ["g_toch"],
        (c) => {
          UI.notify("ã‚°ãƒ³ãƒãƒ¼å¸å›½ãŒèŒ¨åŸã¸æœ€å¾Œé€šç‰’ï¼æ”»æ’ƒé–‹å§‹ï¼", "war");
          let tTag = null;
          Object.keys(Game.countries).forEach((k) => {
            if (Game.countries[k].name.includes("èŒ¨åŸ")) tTag = k;
          });
          if (tTag) Game.declareWar(c.tag, tTag);
        }
      );
      addFocus(
        FT_GUN,
        "g_sait",
        1400,
        700,
        "ã•ã„ãŸã¾å›å»Š",
        "åŸ¼ç‰ã¸å®£æˆ¦å¸ƒå‘Š",
        2500,
        ["g_ibar"],
        (c) => {
          UI.notify("ã‚°ãƒ³ãƒãƒ¼å¸å›½ã€åŸ¼ç‰ã¸å®£æˆ¦å¸ƒå‘Šï¼", "war");
          let tTag = null;
          Object.keys(Game.countries).forEach((k) => {
            if (Game.countries[k].name.includes("åŸ¼ç‰")) tTag = k;
          });
          if (tTag) Game.declareWar(c.tag, tTag);
        }
      );
      addFocus(
        FT_GUN,
        "g_blitz",
        1400,
        850,
        "ã‹ã‚‰ã£é¢¨ãƒ‰ã‚¯ãƒˆãƒªãƒ³",
        "ç§»å‹•é€Ÿåº¦+30%, çªç ´+20%",
        1400,
        ["g_sait"],
        (c) => {
          UI.notify("ã‹ã‚‰ã£é¢¨ãƒ‰ã‚¯ãƒˆãƒªãƒ³æ¡ç”¨ï¼");
          c.speedBonus = (c.speedBonus || 0) + 0.3;
        }
      );
      addFocus(
        FT_GUN,
        "g_niig",
        1200,
        850,
        "æ—¥æœ¬æµ·ã¸ã®å‡ºå£",
        "æ–°æ½Ÿã¸å®£æˆ¦",
        3000,
        ["g_ind"],
        (c) => {
          let tTag = null;
          Object.keys(Game.countries).forEach((k) => {
            if (Game.countries[k].name.includes("æ–°æ½Ÿ")) tTag = k;
          });
          if (tTag) Game.declareWar(c.tag, tTag);
        }
      );
      addFocus(
        FT_GUN,
        "g_wun",
        1600,
        850,
        "ç§˜å¯†å…µå™¨",
        "å·¥å ´+5, XP+100",
        1500,
        ["g_army"],
        (c) => {
          c.fac += 5;
          c.xp += 100;
        }
      );
      addFocus(
        FT_GUN,
        "g_ss",
        1400,
        1000,
        "è¦ªè¡›éšŠç·¨æˆ",
        "äººçš„+100000",
        1200,
        ["g_blitz"],
        (c) => (c.mp += 100000)
      );
      addFocus(
        FT_GUN,
        "g_fort",
        1200,
        1000,
        "çµ¶å¯¾é˜²è¡›ç·š",
        "é˜²å¾¡+30%",
        1200,
        ["g_niig"],
        (c) => (c.territoryDefBonus += 0.3)
      );
      addFocus(
        FT_GUN,
        "g_tot",
        1600,
        1000,
        "ç·åŠ›æˆ¦",
        "å·¥å ´+10, äººçš„+100000",
        2000,
        ["g_wun"],
        (c) => {
          c.fac += 10;
          c.mp += 100000;
        }
      );
      addFocus(
        FT_GUN,
        "g_end",
        1400,
        1200,
        "æ–°æ—¥æœ¬ç§©åº",
        "PP+1000",
        3000,
        ["g_ss"],
        (c) => (c.pp += 1000)
      );
      DB.FocusTree.GUNMA = FT_GUN;

      // 4. TOKYO (UK)
      const FT_TOK = [];
      addFocus(
        FT_TOK,
        "t_def",
        1500,
        100,
        "é¦–éƒ½é˜²è¡›",
        "å®‰å®š+20%",
        700,
        [],
        (c) => (c.st += 20)
      );
      addFocus(
        FT_TOK,
        "t_all",
        1300,
        250,
        "é–¢æ±é€£åˆã®çµæŸ",
        "åŒç›Ÿå›½ã¨ã®é–¢ä¿‚å¼·åŒ–",
        1000,
        ["t_def"],
        (c) => {
          UI.notify("æ±äº¬ãŒé–¢æ±è«¸å›½ã¸æ”¯æ´ã‚’ç´„æŸ", "success");
          c.pp += 100;
        }
      );
      addFocus(
        FT_TOK,
        "t_fort",
        1700,
        250,
        "è¦å¡åŒ–",
        "é˜²å¾¡+10%",
        1000,
        ["t_def"],
        (c) => (c.territoryDefBonus = 0.1)
      );
      addFocus(
        FT_TOK,
        "t_air",
        1500,
        400,
        "é˜²ç©ºç¶²æ•´å‚™",
        "å·¥å ´+3",
        1400,
        ["t_def"],
        (c) => (c.fac += 3)
      );
      addFocus(
        FT_TOK,
        "t_mob",
        1500,
        550,
        "æœ¬åœŸæ±ºæˆ¦æº–å‚™",
        "äººçš„+50000",
        1400,
        ["t_air"],
        (c) => (c.mp += 50000)
      );
      addFocus(
        FT_TOK,
        "t_nav",
        1300,
        550,
        "æµ·è»å¢—å¼·",
        "å·¥å ´+5",
        1500,
        ["t_all"],
        (c) => (c.fac += 5)
      );
      addFocus(
        FT_TOK,
        "t_rad",
        1700,
        550,
        "ãƒ¬ãƒ¼ãƒ€ãƒ¼ç¶²",
        "é˜²å¾¡+10%",
        1200,
        ["t_fort"],
        (c) => (c.territoryDefBonus += 0.1)
      );
      addFocus(
        FT_TOK,
        "t_com",
        1300,
        700,
        "è«¸å³¶çµ±åˆ",
        "äººçš„+30000, PP+100",
        1500,
        ["t_nav"],
        (c) => {
          c.mp += 30000;
          c.pp += 100;
        }
      );
      addFocus(
        FT_TOK,
        "t_bom",
        1700,
        700,
        "æˆ¦ç•¥çˆ†æ’ƒ",
        "å·¥å ´å»ºè¨­é€Ÿåº¦+20%",
        1500,
        ["t_rad"],
        (c) => (c.factoryBuildSpeedBonus = 0.2)
      );
      addFocus(
        FT_TOK,
        "t_down",
        1500,
        850,
        "è‡ªç”±å­˜ç¶šä½œæˆ¦",
        "æ”»æ’ƒ+10%(Flavor)",
        2000,
        ["t_mob"],
        (c) => {}
      );
      DB.FocusTree.TOKYO = FT_TOK;

      // 5. SAITAMA (France)
      const FT_SAI = [];
      addFocus(
        FT_SAI,
        "s_pol",
        1500,
        100,
        "çœŒæ”¿ã®æ··ä¹±",
        "PP-50, å®‰å®š-10%",
        700,
        [],
        (c) => {
          c.pp -= 50;
          c.st -= 10;
        }
      );
      addFocus(
        FT_SAI,
        "s_mag",
        1500,
        250,
        "ã‚µã‚¤ã‚¿ãƒãƒ»ãƒ©ã‚¤ãƒ³",
        "é˜²å¾¡+20%, å·¥å ´+2",
        1400,
        ["s_pol"],
        (c) => {
          c.territoryDefBonus = 0.2;
          c.fac += 2;
        }
      );
      addFocus(
        FT_SAI,
        "s_ref",
        1300,
        400,
        "æ”¿åºœæ”¹é©",
        "PP+200, å®‰å®š+20%",
        1400,
        ["s_pol"],
        (c) => {
          c.pp += 200;
          c.st += 20;
        }
      );
      addFocus(
        FT_SAI,
        "s_ext",
        1700,
        400,
        "ç¾çŠ¶ç¶­æŒ",
        "äººçš„+10000",
        700,
        ["s_pol"],
        (c) => (c.mp += 10000)
      );
      addFocus(
        FT_SAI,
        "s_ext2",
        1500,
        550,
        "ã‚µã‚¤ã‚¿ãƒãƒ©ã‚¤ãƒ³å»¶é•·",
        "é˜²å¾¡+10%",
        1200,
        ["s_mag"],
        (c) => (c.territoryDefBonus += 0.1)
      );
      addFocus(
        FT_SAI,
        "s_com",
        1300,
        550,
        "å…±ç”£åŒ–ãƒ«ãƒ¼ãƒˆ",
        "äººçš„+50000",
        1500,
        ["s_ref"],
        (c) => (c.mp += 50000)
      );
      addFocus(
        FT_SAI,
        "s_ent",
        1700,
        550,
        "å°å”å•†",
        "PP+100",
        1000,
        ["s_ext"],
        (c) => (c.pp += 100)
      );
      addFocus(
        FT_SAI,
        "s_alp",
        1500,
        700,
        "ã‚¢ãƒ«ãƒ—ã‚¹è¦å¡",
        "å·¥å ´+3",
        1500,
        ["s_ext2"],
        (c) => (c.fac += 3)
      );
      addFocus(
        FT_SAI,
        "s_eva",
        1500,
        850,
        "ç”£æ¥­ç–é–‹",
        "å·¥å ´+5",
        2000,
        ["s_alp"],
        (c) => (c.fac += 5)
      );
      DB.FocusTree.SAITAMA = FT_SAI;

      // 6. HOKKAIDO (USSR)
      const FT_HOK = [];
      addFocus(
        FT_HOK,
        "h_rev",
        1500,
        100,
        "åŒ—æµ·é©å‘½",
        "å®‰å®š+50%",
        700,
        [],
        (c) => (c.st = 100)
      );
      addFocus(
        FT_HOK,
        "h_ind",
        1300,
        250,
        "5ã‚«å¹´è¨ˆç”»",
        "å·¥å ´+10",
        2000,
        ["h_rev"],
        (c) => (c.fac += 10)
      );
      addFocus(
        FT_HOK,
        "h_purge",
        1700,
        250,
        "å¤§ç²›æ¸…",
        "å°†æ ¡è¿½æ”¾: XP-50, PP+200",
        1400,
        ["h_rev"],
        (c) => {
          c.xp -= 50;
          c.pp += 200;
        }
      );
      addFocus(
        FT_HOK,
        "h_mass",
        1500,
        400,
        "äººæµ·æˆ¦è¡“",
        "äººçš„+200000",
        1400,
        ["h_ind", "h_purge"],
        (c) => (c.mp += 200000)
      );
      addFocus(
        FT_HOK,
        "h_tank",
        1500,
        550,
        "T-34é‡ç”£",
        "å·¥å ´+5, è£…å‚™+10000",
        1400,
        ["h_mass"],
        (c) => {
          c.fac += 5;
          c.eq += 10000;
        }
      );
      addFocus(
        FT_HOK,
        "h_south",
        1500,
        700,
        "å—ä¸‹æ”¿ç­–",
        "æ±åŒ—(é’æ£®)ã¸å®£æˆ¦å¸ƒå‘Š",
        1000,
        ["h_mass"],
        (c) => {
          UI.notify("åŒ—æµ·ã‚½ãƒ“ã‚¨ãƒˆãŒå—ä¸‹ã‚’é–‹å§‹ï¼æ±åŒ—ã¸ä¾µæ”»ï¼", "war");
          let tTag = null;
          Object.keys(Game.countries).forEach((k) => {
            if (Game.countries[k].name.includes("é’æ£®")) tTag = k;
          });
          if (tTag) Game.declareWar(c.tag, tTag);
        }
      );
      addFocus(
        FT_HOK,
        "h_sib",
        1300,
        700,
        "åŒ—æ–¹é–‹ç™º",
        "å·¥å ´+5",
        1500,
        ["h_ind"],
        (c) => (c.fac += 5)
      );
      addFocus(
        FT_HOK,
        "h_kgb",
        1700,
        700,
        "KGBå‰µè¨­",
        "å®‰å®š+10%",
        1200,
        ["h_purge"],
        (c) => (c.st += 10)
      );
      addFocus(
        FT_HOK,
        "h_cold",
        1500,
        850,
        "å†·æˆ¦æº–å‚™",
        "å·¥å ´+5",
        2000,
        ["h_south"],
        (c) => (c.fac += 5)
      );
      addFocus(
        FT_HOK,
        "h_nuc",
        1500,
        1000,
        "æ ¸å®Ÿé¨“",
        "PP+500",
        3000,
        ["h_cold"],
        (c) => (c.pp += 500)
      );
      DB.FocusTree.HOKKAIDO = FT_HOK;

      const CapitalCoords = {
        P1: { lat: 43.064359, lon: 141.347449 },
        P2: { lat: 40.824294, lon: 140.740054 },
        P3: { lat: 39.70353, lon: 141.152667 },
        P4: { lat: 38.268737, lon: 140.872183 },
        P5: { lat: 39.718175, lon: 140.103356 },
        P6: { lat: 38.240127, lon: 140.362533 },
        P7: { lat: 37.750146, lon: 140.466754 },
        P8: { lat: 36.341817, lon: 140.446796 },
        P9: { lat: 36.56575, lon: 139.883526 },
        P10: { lat: 36.391205, lon: 139.060917 },
        P11: { lat: 35.857771, lon: 139.647804 },
        P12: { lat: 35.604563, lon: 140.123179 },
        P13: { lat: 35.689185, lon: 139.691648 },
        P14: { lat: 35.447505, lon: 139.642347 },
        P15: { lat: 37.901699, lon: 139.022728 },
        P16: { lat: 36.695274, lon: 137.211302 },
        P17: { lat: 36.594729, lon: 136.62555 },
        P18: { lat: 36.06522, lon: 136.221641 },
        P19: { lat: 35.663927, lon: 138.568115 },
        P20: { lat: 36.651304, lon: 138.181061 },
        P21: { lat: 35.39123, lon: 136.722291 },
        P22: { lat: 34.975556, lon: 138.382778 },
        P23: { lat: 35.181474, lon: 136.906403 },
        P24: { lat: 34.730283, lon: 136.508589 },
        P25: { lat: 35.004528, lon: 135.868634 },
        P26: { lat: 35.021071, lon: 135.755607 },
        P27: { lat: 34.686316, lon: 135.519711 },
        P28: { lat: 34.691269, lon: 135.183051 },
        P29: { lat: 34.685318, lon: 135.832743 },
        P30: { lat: 34.226047, lon: 135.167506 },
        P31: { lat: 35.503623, lon: 134.238291 },
        P32: { lat: 35.472295, lon: 133.050499 },
        P33: { lat: 34.661771, lon: 133.935 },
        P34: { lat: 34.39656, lon: 132.459622 },
        P35: { lat: 34.185193, lon: 131.470495 },
        P36: { lat: 34.065833, lon: 134.559444 },
        P37: { lat: 34.340149, lon: 134.043444 },
        P38: { lat: 33.841639, lon: 132.765 },
        P39: { lat: 33.559706, lon: 133.531084 },
        P40: { lat: 33.606785, lon: 130.418315 },
        P41: { lat: 33.249445, lon: 130.29878 },
        P42: { lat: 32.74499, lon: 129.873536 },
        P43: { lat: 32.789825, lon: 130.741667 },
        P44: { lat: 33.2382, lon: 131.612579 },
        P45: { lat: 31.911077, lon: 131.423877 },
        P46: { lat: 31.596553, lon: 130.557115 },
        P47: { lat: 26.212401, lon: 127.680931 },
      };
      const MapSys = { hexes: [] };

      const UI = {
        _lastValues: {},
        init: function () {
          this.update();
        },
        update: function () {
          const p = Game.countries[Game.player];
          if (!p) return;

          const now = Date.now();
          if (!this.lastUpdateTime || now - this.lastUpdateTime > 500) {
            this.lastUpdateTime = now;

            // å€¤ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã®ã¿DOMã‚’æ›´æ–°
            if (this._lastValues.pp !== ~~p.pp) {
              $("res-pp").innerText = ~~p.pp;
              this._lastValues.pp = ~~p.pp;
            }
            if (this._lastValues.st !== p.st + "%") {
              $("res-st").innerText = p.st + "%";
              this._lastValues.st = p.st + "%";
            }
            if (this._lastValues.ws !== p.ws + "%") {
              $("res-ws").innerText = p.ws + "%";
              this._lastValues.ws = p.ws + "%";
            }
            if (this._lastValues.mp !== nFmt(p.mp)) {
              $("res-man").innerText = nFmt(p.mp);
              this._lastValues.mp = nFmt(p.mp);
            }
            if (this._lastValues.eq !== nFmt(p.eq)) {
              $("res-eq").innerText = nFmt(p.eq);
              this._lastValues.eq = nFmt(p.eq);
            }
            if (this._lastValues.xp !== ~~p.xp) {
              $("res-xp").innerText = ~~p.xp;
              this._lastValues.xp = ~~p.xp;
            }
            if (this._lastValues.fac !== p.fac) {
              $("res-fac").innerText = p.fac;
              this._lastValues.fac = p.fac;
            }

            const dObj = new Date(2025, 3, 1 + Game.day);
            const dateStr = `${dObj.getFullYear()}/${
              dObj.getMonth() + 1
            }/${dObj.getDate()}`;
            if (this._lastValues.date !== dateStr) {
              $("game-date").innerText = dateStr;
              this._lastValues.date = dateStr;
            }
          }

          let armyCount = 0;
          Game.units.forEach((u) => {
            if (u.tag === Game.player) armyCount++;
          });

          if (this._lastValues.armyCount !== armyCount) {
            $("army-count").innerText = armyCount;
            this._lastValues.armyCount = armyCount;
          }
          if (this._lastValues.selCount !== Input.selUnits.length) {
            $("sel-count").innerText = Input.selUnits.length;
            this._lastValues.selCount = Input.selUnits.length;
          }

          const tension = Game.tension + "%";
          if (this._lastValues.tension !== tension) {
            $("val-wt").innerText = tension;
            this._lastValues.tension = tension;
          }

          let focusText = "";
          let focusBarWidth = "0%";

          if (p.focus) {
            const pct = (p.focusProg / p.focus.cost) * 100;
            focusText = p.focus.t + " (" + ~~pct + "%)";
            focusBarWidth = Math.min(pct, 100) + "%";
          } else if (p.buildingFactory) {
            const pct =
              (p.buildingFactory.progress / p.buildingFactory.cost) * 100;
            focusText = `${p.buildingFactory.name}ä¸­... (${~~pct}%)`;
            focusBarWidth = Math.min(pct, 100) + "%";
          } else {
            focusText = "çœŒæ”¿æ–¹é‡ã‚’é¸æŠ";
          }

          if (this._lastValues.focusText !== focusText) {
            $("sb-focus-curr").innerText = focusText;
            this._lastValues.focusText = focusText;
          }

          if (this._lastValues.focusBarWidth !== focusBarWidth) {
            $("sb-focus-bar").style.width = focusBarWidth;
            this._lastValues.focusBarWidth = focusBarWidth;
          }
        },
        updateSidebar: function () {
          const t = Game.selected || Game.player;
          const c = Game.countries[t];
          if (!c) return;
          $("sb-name").innerText = c.name;
          $("sb-portrait").innerText = c.flag;
          $("sb-ideology").innerText = "æ”¿å…š: " + (c.ideology || "çœŒæ°‘å…š");
          const diploMsg = $("diplo-msg");
          const diploContent = $("diplo-content");
          if (Game.selected && Game.selected !== Game.player) {
            diploMsg.style.display = "none";
            diploContent.style.display = "block";
            $("dp-name").innerText = c.name;
            $("dp-faction").innerText = c.faction || "ãªã—";
            $("dp-war-status").style.display = Game.isWar(Game.player, t)
              ? "block"
              : "none";
            $("btn-declare-war").disabled = Game.isAlly(Game.player, t);
            if (!("ontouchstart" in window))
              $("sidebar").style.display = "flex";
            else $("sidebar").classList.add("show");
          } else {
            diploMsg.style.display = "block";
            diploContent.style.display = "none";
          }
        },
        toggleSidebar: function () {
          const s = $("sidebar");
          if (window.innerWidth <= 600) s.classList.toggle("show");
          else s.style.display = s.style.display === "none" ? "flex" : "none";
        },
        tab: function (id) {
          document
            .querySelectorAll(".tab")
            .forEach((e) => e.classList.remove("active"));
          document
            .querySelectorAll(".view")
            .forEach((e) => e.classList.remove("active"));
          event.target.classList.add("active");
          $(`v-${id}`).classList.add("active");
        },
        openFocusTree: function () {
          const p = Game.countries[Game.player];
          if (!p) return;
          const tree = DB.FocusTree[p.treeType] || DB.FocusTree.GENERIC;
          $("focus-nodes").innerHTML = "";
          $("focus-lines").innerHTML = "";
          tree.forEach((f) => {
            const el = $c("div", "focus-node");
            el.style.left = f.x + "px";
            el.style.top = f.y + "px";
            el.innerHTML = `<div class="focus-title">${f.t}</div><div class="focus-desc">${f.d}</div><div class="focus-cost">(${f.cost} days)</div>`;
            const comp = p.completedFocuses.includes(f.id);
            const excluded =
              f.mut && f.mut.some((m) => p.completedFocuses.includes(m));
            const avail =
              !comp &&
              !excluded &&
              f.req.every((r) => p.completedFocuses.includes(r));

            const condMet = !f.cond || f.cond(p);
            if (comp) el.classList.add("completed");
            else if (excluded) el.classList.add("exclusive-locked");
            else if (
              avail &&
              condMet &&
              !((p.focus && p.focus.id !== f.id) || p.buildingFactory)
            ) {
              el.classList.add("available");
              el.onclick = () => Game.startFocus(f.id);
            } else {
              el.classList.add("locked");
              if (avail && !condMet)
                el.innerHTML += `<div style="color:#d32f2f;font-weight:bold;margin-top:2px">æ¡ä»¶æœªé”æˆ</div>`;
            }
            if (p.focus && p.focus.id === f.id) el.classList.add("available");
            $("focus-nodes").appendChild(el);
            f.req.forEach((rid) => {
              const par = tree.find((x) => x.id === rid);
              if (par) {
                const l = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "line"
                );
                l.setAttribute("x1", par.x + 120);
                l.setAttribute("y1", par.y + 110);
                l.setAttribute("x2", f.x + 120);
                l.setAttribute("y2", f.y);
                l.setAttribute("stroke", comp ? "var(--hl)" : "#555");
                l.setAttribute("stroke-width", "2");
                $("focus-lines").appendChild(l);
              }
            });
            if (f.mut)
              f.mut.forEach((mid) => {
                const mNode = tree.find((x) => x.id === mid);
                if (mNode && mNode.x > f.x) {
                  const l2 = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "line"
                  );
                  l2.setAttribute("x1", f.x + 200);
                  l2.setAttribute("y1", f.y + 40);
                  l2.setAttribute("x2", mNode.x + 40);
                  l2.setAttribute("y2", mNode.y + 40);
                  l2.setAttribute("stroke", "#b71c1c");
                  l2.setAttribute("stroke-width", "2");
                  l2.setAttribute("stroke-dasharray", "5,5");
                  $("focus-lines").appendChild(l2);
                }
              });
          });
          const modal = $("focus-modal");
          modal.style.display = "flex";

          // ãƒ‰ãƒ©ãƒƒã‚°ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
          const area = $("focus-scroll-area");
          area.scrollLeft = 1000;
          area.scrollTop = 0;
          let isDown = false,
            sX,
            sY,
            sL,
            sT;
          const startDrag = (x, y) => {
            isDown = true;
            sX = x;
            sY = y;
            sL = area.scrollLeft;
            sT = area.scrollTop;
            area.style.cursor = "grabbing";
          };
          const doDrag = (x, y) => {
            if (!isDown) return;
            area.scrollLeft = sL - (x - sX);
            area.scrollTop = sT - (y - sY);
          };
          const endDrag = () => {
            isDown = false;
            area.style.cursor = "grab";
          };
          area.onmousedown = (e) => startDrag(e.pageX, e.pageY);
          area.onmousemove = (e) => {
            if (isDown) e.preventDefault();
            doDrag(e.pageX, e.pageY);
          };
          area.onmouseup = endDrag;
          area.onmouseleave = endDrag;

          area.addEventListener(
            "touchstart",
            (e) => {
              if (e.touches.length === 1)
                startDrag(e.touches[0].pageX, e.touches[0].pageY);
            },
            { passive: false }
          );
          area.addEventListener(
            "touchmove",
            (e) => {
              if (e.touches.length === 1) {
                e.preventDefault();
                doDrag(e.touches[0].pageX, e.touches[0].pageY);
              }
            },
            { passive: false }
          );
          area.addEventListener("touchend", endDrag);
        },
        openDesigner: function () {
          Designer.open();
        },
        closeDesigner: function () {
          $("design-modal").style.display = "none";
        },
        updateFocusModal: function () {
          if ($("focus-modal").style.display === "flex") this.openFocusTree();
        },
        closeFocusTree: function () {
          $("focus-modal").style.display = "none";
        },
        notify: function (m, t) {
          const d = $c("div", "news");
          d.innerHTML = `<div style="font-weight:bold;margin-bottom:3px;color:#aaa">Day ${Game.day}</div>${m}`;
          if (t === "war") {
            d.style.borderLeftColor = "var(--danger)";
            d.style.background = "rgba(60,10,10,.95)";
          } else if (t === "success") d.style.borderLeftColor = "var(--hl)";
          else if (t === "warn") {
            d.style.borderLeftColor = "var(--warn)";
            d.style.background = "rgba(60,60,10,.95)";
          }
          $("news-feed").prepend(d);
          // å¤ã„ãƒ‹ãƒ¥ãƒ¼ã‚¹ã‚’è‡ªå‹•å‰Šé™¤ã—ã¦DOMè¦ç´ ã‚’æ¸›ã‚‰ã™
          const newsItems = $("news-feed").children;
          if (newsItems.length > 5) {
            // æœ€å¤§5ä»¶ã«åˆ¶é™
            newsItems[newsItems.length - 1].remove();
          }
          setTimeout(() => d.remove(), 6000);
        },
        showStartScreen: function () {
          const list = $("country-list");
          list.innerHTML = "";
          const sortedTags = Object.keys(Game.countries)
            .filter((t) => t !== "_SEA")
            .sort((a, b) => Game.countries[b].fac - Game.countries[a].fac);
          sortedTags.forEach((tag) => {
            const c = Game.countries[tag];
            if (c.provs.length === 0) return;
            const d = $c("div", "country-card");
            d.innerHTML = `<div class="c-flag" style="color:${c.col}">${
              c.flag
            }</div><div class="c-name">${
              c.name
            }</div><div class="c-info">å·¥å ´:${c.fac} äººçš„:${nFmt(c.mp)}</div>`;
            d.onclick = () => Game.startGame(tag);
            list.appendChild(d);
          });
          $("start-screen").style.display = "flex";
          $("loading-overlay").style.display = "none";
        },
      };

      const Designer = {
        current: { bat: [], sup: [] },
        open: function () {
          const p = Game.countries[Game.player];
          if (!p) return;
          this.current = { bat: [...p.template.bat], sup: [...p.template.sup] };
          const xpEl = $("ds-xp");
          if (xpEl) xpEl.innerText = ~~p.xp;
          $("design-modal").style.display = "flex";
          this.renderOptions();
          this.updateGrid();
        },
        renderOptions: function () {
          const batDiv = $("opt-battalions");
          const supDiv = $("opt-support");
          if (!batDiv || !supDiv) return;
          batDiv.innerHTML = "";
          supDiv.innerHTML = "";
          Object.keys(DB.UnitTypes).forEach((key) => {
            const u = DB.UnitTypes[key];
            const el = $c("div", "unit-opt");
            el.innerHTML = `<span class="unit-opt-icon">${u.icon}</span><span>${u.name}</span><span style="font-size:10px;color:#aaa;margin-left:auto">Cost:${u.cost}</span>`;
            el.onclick = () => this.addUnit(key, u.type);
            if (u.type === "bat") batDiv.appendChild(el);
            else supDiv.appendChild(el);
          });
        },
        addUnit: function (id, type) {
          if (type === "bat") {
            if (this.current.bat.length < 9) {
              this.current.bat.push(id);
              this.updateGrid();
            } else UI.notify("ä¸»åŠ›å¤§éšŠã¯ã“ã‚Œä»¥ä¸Šè¿½åŠ ã§ãã¾ã›ã‚“", "warn");
          } else {
            if (this.current.sup.length < 3 && !this.current.sup.includes(id)) {
              this.current.sup.push(id);
              this.updateGrid();
            } else
              UI.notify("æ”¯æ´ä¸­éšŠã¯è¿½åŠ ã§ããªã„ã‹ã€æ—¢ã«å­˜åœ¨ã—ã¾ã™", "warn");
          }
        },
        removeUnit: function (idx, type) {
          if (type === "bat") this.current.bat.splice(idx, 1);
          else this.current.sup.splice(idx, 1);
          this.updateGrid();
        },
        updateGrid: function () {
          const gb = $("grid-bat");
          const gs = $("grid-sup");
          if (!gb || !gs) return;
          gb.innerHTML = "";
          gs.innerHTML = "";
          this.current.bat.forEach((uid, i) => {
            const u = DB.UnitTypes[uid];
            const el = $c("div", "slot filled");
            el.innerHTML = `${u.icon}<div class="rm" onclick="event.stopPropagation();Designer.removeUnit(${i},'bat')">Ã—</div>`;
            gb.appendChild(el);
          });
          for (let i = this.current.bat.length; i < 6; i++) {
            gb.appendChild($c("div", "slot"));
          }
          this.current.sup.forEach((uid, i) => {
            const u = DB.UnitTypes[uid];
            const el = $c("div", "slot filled");
            el.innerHTML = `${u.icon}<div class="rm" onclick="event.stopPropagation();Designer.removeUnit(${i},'sup')">Ã—</div>`;
            gs.appendChild(el);
          });
          for (let i = this.current.sup.length; i < 3; i++) {
            gs.appendChild($c("div", "slot"));
          }
          this.calcPreview();
        },
        calcPreview: function () {
          const s = Game.calcStats(this.current);
          if ($("ds-atk-s")) $("ds-atk-s").innerText = s.sa.toFixed(1);
          if ($("ds-atk-h")) $("ds-atk-h").innerText = s.ha.toFixed(1);
          if ($("ds-def")) $("ds-def").innerText = s.def.toFixed(1);
          if ($("ds-brk")) $("ds-brk").innerText = s.brk.toFixed(1);
          if ($("ds-arm")) $("ds-arm").innerText = s.arm.toFixed(1);
          if ($("ds-cost")) $("ds-cost").innerText = s.cost.toFixed(0);
        },
        save: function () {
          const p = Game.countries[Game.player];
          const cost = 10;
          if (p.xp < cost) {
            UI.notify(`é™¸è»çµŒé¨“å€¤ãŒè¶³ã‚Šã¾ã›ã‚“ (å¿…è¦: ${cost})`, "warn");
            return;
          }
          if (this.current.bat.length === 0) {
            UI.notify("å°‘ãªãã¨ã‚‚1ã¤ã®ä¸»åŠ›å¤§éšŠãŒå¿…è¦ã§ã™", "warn");
            return;
          }
          p.xp -= cost;
          p.template = {
            bat: [...this.current.bat],
            sup: [...this.current.sup],
          };
          UI.notify("å¸«å›£ç·¨æˆã‚’ä¿å­˜ã—ã¾ã—ãŸ", "success");
          UI.closeDesigner();
          UI.update();
        },
      };

      const Input = {
        isDown: false,
        isDrag: false,
        isShift: false,
        isRight: false,
        sx: 0,
        sy: 0,
        lastX: 0,
        lastY: 0,
        selUnits: [],
        battlePoints: [],
        battleLineEl: null,
        mapWrapEl: null,
        pinchDist: 0,
        pinchStartScale: 1,
        planMode: false,
        pathCache: new Map(),

        init: function () {
          this.mapWrapEl = $("map-wrap");
          window.addEventListener("keydown", (e) => {
            if (e.key === "Shift") this.isShift = true;
          });
          window.addEventListener("keyup", (e) => {
            if (e.key === "Shift") this.isShift = false;
          });

          this.mapWrapEl.addEventListener("mousedown", (e) => {
            this.isDown = true;
            this.isDrag = false;
            this.sx = e.clientX;
            this.sy = e.clientY;
            this.lastX = e.clientX;
            this.lastY = e.clientY;
            this.isRight = e.button === 2;
            if (e.button === 1) e.preventDefault();

            const isDrawingAction =
              this.isRight || (this.planMode && e.button === 0);
            if (isDrawingAction && this.selUnits.length > 0) {
              this.battlePoints = [];
              this.startBattleLine({ clientX: e.clientX, clientY: e.clientY });
            }
            this.mapWrapEl.style.cursor = "grabbing";
          });
          window.addEventListener("mousemove", (e) => {
            if (!this.isDown) return;
            const dx = e.clientX - this.lastX,
              dy = e.clientY - this.lastY;
            if (
              Math.abs(e.clientX - this.sx) > 5 ||
              Math.abs(e.clientY - this.sy) > 5
            ) {
              this.isDrag = true;
              this.mapWrapEl.style.pointerEvents = "none";
            }

            const isDrawingAction =
              this.isRight || (this.planMode && e.buttons === 1);
            if (this.isShift && !this.isRight && !this.planMode) {
              this.updateBoxSelect(e);
            } else if (isDrawingAction && this.selUnits.length > 0) {
              this.updateBattleLine({ clientX: e.clientX, clientY: e.clientY });
            } else if (!isDrawingAction && this.isDrag) {
              Renderer.x += dx;
              Renderer.y += dy;
              Renderer.update();
            }
            this.lastX = e.clientX;
            this.lastY = e.clientY;
          });
          window.addEventListener("mouseup", (e) => {
            this.isDown = false;
            this.mapWrapEl.style.cursor = "grab";
            this.mapWrapEl.style.pointerEvents = "auto";
            $("select-box").style.display = "none";

            const isDrawingAction =
              this.isRight || (this.planMode && e.button === 0);
            if (this.isDrag) {
              if (this.isShift && !isDrawingAction) this.finishBoxSelect();
              else if (isDrawingAction && this.selUnits.length > 0)
                this.executeBattlePlan();
              return;
            }
            if (!this.planMode && !this.isRight) {
              const target = e.target;
              if (target.classList.contains("hex")) {
                const h = MapSys.hexes[target.dataset.id];
                if (h) this.onHexClick(e, h);
              } else if (target.closest(".unit-grp")) {
                const uEl = target.closest(".unit-grp");
                const u = Game.units.find((x) => x.el === uEl);
                if (u) {
                  e.stopPropagation();
                  this.onHexClick(e, u.hex);
                }
              }
            }
          });
          this.mapWrapEl.addEventListener(
            "wheel",
            (e) => {
              e.preventDefault();
              const f = e.deltaY > 0 ? 0.9 : 1.1;
              Renderer.s = Math.max(0.4, Math.min(5, Renderer.s * f));
              Renderer.update();
            },
            { passive: false }
          );

          this.mapWrapEl.addEventListener(
            "touchstart",
            (e) => {
              if (e.touches.length === 1) {
                this.isDown = true;
                this.isDrag = false;
                this.sx = e.touches[0].clientX;
                this.sy = e.touches[0].clientY;
                this.lastX = this.sx;
                this.lastY = this.sy;
                this.isRight = false;

                if (this.planMode && this.selUnits.length > 0) {
                  this.battlePoints = [];
                  this.startBattleLine(e.touches[0]);
                }
              } else if (e.touches.length === 2) {
                this.isDown = false;
                this.pinchDist = Math.hypot(
                  e.touches[0].clientX - e.touches[1].clientX,
                  e.touches[0].clientY - e.touches[1].clientY
                );
                this.pinchStartScale = Renderer.s;
              }
            },
            { passive: false }
          );
          this.mapWrapEl.addEventListener(
            "touchmove",
            (e) => {
              if (this.planMode) e.preventDefault();
              if (e.touches.length === 1 && this.isDown) {
                const cx = e.touches[0].clientX;
                const cy = e.touches[0].clientY;

                if (this.planMode && this.selUnits.length > 0) {
                  this.updateBattleLine(e.touches[0]);
                } else {
                  const dx = cx - this.lastX;
                  const dy = cy - this.lastY;
                  if (
                    Math.abs(cx - this.sx) > 5 ||
                    Math.abs(cy - this.sy) > 5
                  ) {
                    this.isDrag = true;
                    this.mapWrapEl.style.pointerEvents = "none";
                  }
                  if (this.isDrag) {
                    Renderer.x += dx;
                    Renderer.y += dy;
                    Renderer.update();
                  }
                }
                this.lastX = cx;
                this.lastY = cy;
              } else if (e.touches.length === 2) {
                e.preventDefault();
                const dist = Math.hypot(
                  e.touches[0].clientX - e.touches[1].clientX,
                  e.touches[0].clientY - e.touches[1].clientY
                );
                const scale = (dist / this.pinchDist) * this.pinchStartScale;
                Renderer.s = Math.max(0.4, Math.min(5, scale));
                Renderer.update();
              }
            },
            { passive: false }
          );
          this.mapWrapEl.addEventListener("touchend", (e) => {
            this.isDown = false;
            this.mapWrapEl.style.pointerEvents = "auto";

            if (
              this.planMode &&
              this.selUnits.length > 0 &&
              this.battlePoints.length > 1
            ) {
              this.executeBattlePlan();
              this.togglePlanMode();
              return;
            } else if (
              !this.isDrag &&
              e.changedTouches.length > 0 &&
              !this.planMode
            ) {
              const t = document.elementFromPoint(
                e.changedTouches[0].clientX,
                e.changedTouches[0].clientY
              );
              if (t) {
                if (t.classList.contains("hex")) {
                  const h = MapSys.hexes[t.dataset.id];
                  if (h)
                    this.onHexClick({ button: 0, preventDefault: () => {} }, h);
                } else if (t.closest(".unit-grp")) {
                  const uEl = t.closest(".unit-grp");
                  const u = Game.units.find((x) => x.el === uEl);
                  if (u)
                    this.onHexClick(
                      { button: 0, preventDefault: () => {} },
                      u.hex
                    );
                }
              }
            }
          });
        },
        togglePlanMode: function () {
          this.planMode = !this.planMode;
          const btn = $("btn-plan-mode");
          if (this.planMode) {
            btn.classList.add("active");
            UI.notify("ä½œæˆ¦ãƒ¢ãƒ¼ãƒ‰: ON (ãªãã£ã¦ç§»å‹•)", "warn");
          } else {
            btn.classList.remove("active");
            UI.notify("ä½œæˆ¦ãƒ¢ãƒ¼ãƒ‰: OFF");
          }
        },
        updateBoxSelect: function (e) {
          const box = $("select-box");
          const x = Math.min(this.sx, e.clientX),
            y = Math.min(this.sy, e.clientY);
          const w = Math.abs(e.clientX - this.sx),
            h = Math.abs(e.clientY - this.sy);
          box.style.left = x + "px";
          box.style.top = y + "px";
          box.style.width = w + "px";
          box.style.height = h + "px";
          box.style.display = "block";
        },
        finishBoxSelect: function () {
          const b = $("select-box").getBoundingClientRect();
          const mapWrapRect = this.mapWrapEl.getBoundingClientRect();
          this.selUnits = Game.units.filter((u) => {
            if (u.tag !== Game.player) return false;
            const sx = u.x * Renderer.s + Renderer.x + mapWrapRect.left;
            const sy = u.y * Renderer.s + Renderer.y + mapWrapRect.top;
            return (
              sx >= b.left && sx <= b.right && sy >= b.top && sy <= b.bottom
            );
          });
          this.hlUnits();
        },
        startBattleLine: function (ptObj) {
          const pt = this.screenToWorld(ptObj.clientX, ptObj.clientY);
          this.battlePoints.push(pt);
          if (this.battleLineEl) this.battleLineEl.remove();
          this.battleLineEl = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "polyline"
          );
          this.battleLineEl.setAttribute("class", "battle-line");
          Renderer.uiLayer.appendChild(this.battleLineEl);
        },
        updateBattleLine: function (ptObj) {
          const pt = this.screenToWorld(ptObj.clientX, ptObj.clientY);
          const last = this.battlePoints[this.battlePoints.length - 1];
          if (!last || Math.hypot(pt.x - last.x, pt.y - last.y) > 10) {
            this.battlePoints.push(pt);
            const ptsStr = this.battlePoints
              .map((p) => `${p.x},${p.y}`)
              .join(" ");
            this.battleLineEl.setAttribute("points", ptsStr);
          }
        },
        executeBattlePlan: function () {
          if (!this.battleLineEl) return;
          this.battleLineEl.remove();
          this.battleLineEl = null;
          if (this.battlePoints.length < 2) return;

          const targetHexes = [];
          this.battlePoints.forEach((pt) => {
            let closest = null,
              minD = Infinity;
            MapSys.hexes.forEach((h) => {
              if (Math.abs(h.x - pt.x) > 80 || Math.abs(h.y - pt.y) > 80)
                return;
              const d = (h.x - pt.x) ** 2 + (h.y - pt.y) ** 2;
              if (d < 2500) {
                if (d < minD) {
                  minD = d;
                  closest = h;
                }
              }
            });
            if (closest && !targetHexes.includes(closest))
              targetHexes.push(closest);
          });

          if (targetHexes.length === 0) {
            UI.notify("æœ‰åŠ¹ãªç§»å‹•å…ˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", "warn");
            return;
          }

          const sortedUnits = [...this.selUnits].sort((a, b) => a.y - b.y);
          let moveCount = 0;
          sortedUnits.forEach((u, i) => {
            const targetIndex = ~~(
              (i / sortedUnits.length) *
              targetHexes.length
            );
            const target = targetHexes[targetIndex];
            const path = this.findPath(u.hex, target, u.tag, 5000);
            if (path && path.length > 0) {
              u.path = path;
              u.state = "moving";
              moveCount++;
            }
          });
          if (moveCount > 0) UI.notify(`${moveCount} å¸«å›£ãŒä½œæˆ¦è¡Œå‹•ã‚’é–‹å§‹`);
          else UI.notify("ç§»å‹•çµŒè·¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ", "warn");
        },
        screenToWorld: function (sx, sy) {
          const rect = this.mapWrapEl.getBoundingClientRect();
          return {
            x: (sx - rect.left - Renderer.x) / Renderer.s,
            y: (sy - rect.top - Renderer.y) / Renderer.s,
          };
        },
        onHexClick: function (e, hex) {
          if (e.button === 0) {
            if (hex.owner && hex.owner !== "_SEA") {
              Game.selected = hex.owner;
              UI.updateSidebar();
            } else {
              Game.selected = null;
              UI.updateSidebar();
            }
            const myUnitsInHex = Game.units.filter(
              (u) => u.tag === Game.player && u.hex === hex
            );
            if (myUnitsInHex.length > 0) {
              if (this.isShift) {
                myUnitsInHex.forEach((u) => {
                  const idx = this.selUnits.indexOf(u);
                  if (idx >= 0) this.selUnits.splice(idx, 1);
                  else this.selUnits.push(u);
                });
              } else {
                this.selUnits = myUnitsInHex;
              }
            } else {
              if (!this.isShift) this.selUnits = [];
            }
            this.hlUnits();
          } else if (e.button === 2 && this.selUnits.length) {
            const uTag = this.selUnits[0].tag;
            const path = this.findPath(this.selUnits[0].hex, hex, uTag, 5000); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯æ¢ç´¢æ·±åº¦ã‚’æ·±ã
            if (path && path.length > 0) {
              this.selUnits.forEach((u) => {
                u.path = [...path];
                u.state = "moving";
              });
              const m = document.createElement("div");
              m.style.cssText = `position:absolute;left:${e.clientX}px;top:${e.clientY}px;width:10px;height:10px;background:#0f0;border-radius:50%;pointer-events:none;z-index:99;animation:fade 1s;`;
              document.body.appendChild(m);
              setTimeout(() => m.remove(), 1000);
            } else {
              UI.notify("ç§»å‹•ã§ãã¾ã›ã‚“", "warn");
            }
          }
        },
        hlUnits: function () {
          document
            .querySelectorAll(".unit-grp")
            .forEach((el) => el.classList.remove("selected"));
          this.selUnits.forEach((u) => u.el.classList.add("selected"));
          $("sel-count").innerText = this.selUnits.length;

          const btn = $("btn-plan-mode");
          if (this.selUnits.length > 0) {
            btn.style.display = "flex";
          } else {
            btn.style.display = "none";
            this.planMode = false;
            btn.classList.remove("active");
          }
        },
        findPath: function (start, end, unitTag, maxSearch = 300) {
          const cacheKey = `${start.id}-${end.id}-${unitTag}`;
          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æœ‰åŠ¹æœŸé™ã‚’çŸ­ãã—ã¦ã€æˆ¦æ³ã®å¤‰åŒ–ã«æ•æ„Ÿã«ã™ã‚‹ (2æ—¥)
          if (this.pathCache.has(cacheKey)) {
            const cached = this.pathCache.get(cacheKey);
            if (Game.day - cached.day < 2) return [...cached.path];
          }

          if (!start || !end) return null;
          if (start === end) return [];

          const openList = [start];
          const closedSet = new Set();
          const cameFrom = new Map();
          const gScore = new Map();
          gScore.set(start.id, 0);
          const fScore = new Map();
          const getH = (n) => Math.hypot(n.x - end.x, n.y - end.y);
          fScore.set(start.id, getH(start));

          let steps = 0;

          while (openList.length > 0) {
            if (steps++ > maxSearch) break; // æ¢ç´¢æ·±åº¦åˆ¶é™

            openList.sort((a, b) => {
              const fa = fScore.get(a.id);
              const fb = fScore.get(b.id);
              return fa - fb;
            });

            const current = openList.shift();

            if (current === end) {
              const path = [];
              let temp = current;
              while (temp && temp !== start) {
                path.unshift(temp);
                temp = cameFrom.get(temp.id);
              }
              // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ã‚µã‚¤ã‚ºåˆ¶é™
              if (this.pathCache.size > 2000) {
                // å¤ã„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤
                const oldestKey = this.pathCache.keys().next().value;
                this.pathCache.delete(oldestKey);
              }
              this.pathCache.set(cacheKey, { path: path, day: Game.day });
              return path;
            }

            closedSet.add(current.id);

            for (const neighbor of current.adj) {
              if (!neighbor) continue;
              if (closedSet.has(neighbor.id)) continue;

              const isSea = neighbor.owner === "_SEA";
              const isMyLand = neighbor.owner === unitTag;
              const isWarTarget = Game.isWar(unitTag, neighbor.owner);
              const isAlly = Game.isAlly(unitTag, neighbor.owner);

              // æ•µåœ°(isWarTarget)ã‚‚é€šéå¯èƒ½ã¨ã—ã¦ã‚³ã‚¹ãƒˆè¨ˆç®—ã«å«ã‚ã‚‹
              if (!isSea && !isMyLand && !isWarTarget && !isAlly) {
                continue;
              }

              // æ•µåœ°ã¸ã®ç§»å‹•ã¯ã‚³ã‚¹ãƒˆã‚’é«˜ãã™ã‚‹ï¼ˆå®‰å…¨ãªè‡ªé ˜åœŸã‚’é€šã‚‹ãƒ«ãƒ¼ãƒˆã‚’å„ªå…ˆã•ã›ã¤ã¤ã€å¿…è¦ãªã‚‰æ•µåœ°ã‚’è¡Œãï¼‰
              const baseCost = isSea ? 5 : 1;
              const warCost = isWarTarget ? 3 : 0; // æ•µåœ°ã¯ã‚³ã‚¹ãƒˆå¢—
              const moveCost = baseCost + warCost;

              const tentativeG = gScore.get(current.id) + moveCost;

              if (
                !gScore.has(neighbor.id) ||
                tentativeG < gScore.get(neighbor.id)
              ) {
                cameFrom.set(neighbor.id, current);
                gScore.set(neighbor.id, tentativeG);
                fScore.set(neighbor.id, tentativeG + getH(neighbor));

                if (!openList.includes(neighbor)) {
                  openList.push(neighbor);
                }
              }
            }
          }
          return null;
        },
      };

      const Renderer = {
        x: 0,
        y: 0,
        s: 1,
        layer: null,
        uiLayer: null,
        gameSvg: null,
        cachedMapBounds: null,

        update: function () {
          $(
            "game-svg"
          ).style.transform = `translate3d(${this.x}px, ${this.y}px, 0) scale(${this.s})`;
        },

        cacheBounds: function () {
          this.cachedMapBounds = Input.mapWrapEl.getBoundingClientRect();
        },

        addUnit: function (u) {
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.className.baseVal = "unit-grp";
          const inner = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );
          inner.classList.add("unit-inner");
          inner.innerHTML = `<rect class="unit-box" x="-11" y="-7"/><rect class="unit-bar" x="-10" y="5" width="20" height="2"/><rect class="unit-org-bar" x="-10" y="3" width="20" height="2"/><text class="unit-icon" y="3">${u.icon}</text>`;
          g.appendChild(inner);
          g.setAttribute(
            "transform",
            `translate(${u.x.toFixed(1)},${u.y.toFixed(1)})`
          );
          this.layer.appendChild(g);
          u.el = g;
          u.innerEl = inner;
          u.bar = inner.querySelector(".unit-bar");
          u.orgBar = inner.querySelector(".unit-org-bar");
          u.lastRenderX = u.x;
          u.lastRenderY = u.y;
          u.lastHpW = 0; // åˆå›æç”»ç”¨ã«åˆæœŸåŒ–
          u.lastOrgW = 0; // åˆå›æç”»ç”¨ã«åˆæœŸåŒ–

          const noSupply = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          noSupply.textContent = "!";
          noSupply.setAttribute("class", "no-supply-icon");
          noSupply.setAttribute("x", "6");
          noSupply.setAttribute("y", "-3");
          noSupply.style.display = "none";
          inner.appendChild(noSupply);
          u.noSupplyIcon = noSupply;
        },
        updateUnit: function (u) {
          // è»½é‡åŒ–: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸBoundsã‚’ä½¿ç”¨
          const mapWrapRect = this.cachedMapBounds;
          if (!mapWrapRect) return; // åˆå›ç”¨

          const screenX = u.x * this.s + this.x;
          const screenY = u.y * this.s + this.y;
          const padding = 50; // ç”»é¢å¤–ã‚«ãƒªãƒ³ã‚°ã®ä½™è£•

          // ãƒ¦ãƒ‹ãƒƒãƒˆè¦ç´ ãŒã¾ã å­˜åœ¨ã—ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
          if (!u.el) return;

          // ç”»é¢å¤–ã‚«ãƒªãƒ³ã‚° (DOMæ›´æ–°ã‚’ã‚¹ã‚­ãƒƒãƒ—)
          if (
            screenX < -padding ||
            screenX > mapWrapRect.width + padding ||
            screenY < -padding ||
            screenY > mapWrapRect.height + padding
          ) {
            if (u.el.style.display !== "none") u.el.style.display = "none";
            return;
          }
          if (u.el.style.display === "none") u.el.style.display = "";

          // å®‰å…¨è£…ç½®: åº§æ¨™ãŒä¸æ­£ãªã‚‰ãƒ˜ã‚¯ã‚¹ä¸­å¿ƒã«å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆ
          if (!isFinite(u.x) || !isFinite(u.y)) {
            u.x = u.hex.x;
            u.y = u.hex.y;
          }

          // ãƒ¦ãƒ‹ãƒƒãƒˆã®ä½ç½®æ›´æ–°ã¯ã€å®Ÿéš›ã®ç§»å‹•ãŒã‚ã£ãŸå ´åˆã®ã¿
          if (
            Math.abs(u.x - u.lastRenderX) > 0.5 || // é–¾å€¤ã‚’è¨­ã‘ã¦å¾®ç´°ãªå‹•ãã§ã¯æ›´æ–°ã—ãªã„
            Math.abs(u.y - u.lastRenderY) > 0.5
          ) {
            u.el.setAttribute(
              "transform",
              `translate(${u.x.toFixed(1)},${u.y.toFixed(1)})`
            );
            u.lastRenderX = u.x;
            u.lastRenderY = u.y;
          }

          // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ã®æ›´æ–°ã¯ã€å€¤ãŒä¸€å®šé‡å¤‰åŒ–ã—ãŸå ´åˆã®ã¿è¡Œã†
          const hpW = (u.hp / 100) * 20;
          const orgW = (u.org / u.maxOrg) * 20;
          const updateThreshold = 1; // 1pxä»¥ä¸Šã®å¤‰åŒ–ã§æ›´æ–°

          if (Math.abs(u.lastHpW - hpW) > updateThreshold) {
            u.bar.setAttribute("width", Math.max(0, hpW));
            u.lastHpW = hpW;
          }
          if (Math.abs(u.lastOrgW - orgW) > updateThreshold) {
            u.orgBar.setAttribute("width", Math.max(0, orgW));
            u.lastOrgW = orgW;
          }

          // è£œçµ¦ã‚¢ã‚¤ã‚³ãƒ³ã®è¡¨ç¤º/éè¡¨ç¤ºã‚‚çŠ¶æ…‹å¤‰åŒ–æ™‚ã®ã¿
          const needsSupplyIcon = u.supply < 30;
          if (needsSupplyIcon && u.noSupplyIcon.style.display === "none") {
            u.noSupplyIcon.style.display = "block";
          } else if (
            !needsSupplyIcon &&
            u.noSupplyIcon.style.display === "block"
          ) {
            u.noSupplyIcon.style.display = "none";
          }
        },
      };

      const Game = {
        day: 1,
        speed: 1,
        running: false,
        player: "",
        countries: {},
        units: [],
        wars: [],
        tension: 0,
        aiTimer: 0,
        geoData: null,
        isMapOverridden: false,
        unitGrid: new Map(),
        lastSuperEventDay: 0,
        aiIndex: 0,
        accTime: 0,
        lastTime: 0,
        tickDuration: 0.15,

        init: async function () {
          if (!this.isMapOverridden) {
            await this.loadMapData();
          }
          Input.init();
          this.initCountries();
          this.initMap();
          UI.showStartScreen();
        },
        startGame: function (playerTag) {
          this.player = playerTag;
          this.countries[this.player].col = "#b71c1c";
          MapSys.hexes.forEach((h) => {
            if (h.owner === this.player) h.el.setAttribute("fill", "#b71c1c");
          });
          $("start-screen").style.display = "none";
          this.spawnInitialUnits();

          const cap = this.countries[this.player].capital;
          if (cap) {
            const wrapW = Input.mapWrapEl.clientWidth;
            const wrapH = Input.mapWrapEl.clientHeight;
            Renderer.x = wrapW / 2 - cap.x * Renderer.s;
            Renderer.y = wrapH / 2 - cap.y * Renderer.s;
            Renderer.update();
          }

          UI.init();
          this.setSpeed(1);
          this.lastTime = performance.now();
          requestAnimationFrame((t) => this.loop(t));
        },
        loadMapData: async function () {
          try {
            const res = await fetch(
              "https://raw.githubusercontent.com/dataofjapan/land/master/japan.geojson"
            );
            if (!res.ok) throw new Error("Network response was not ok");
            this.geoData = await res.json();
          } catch (e) {
            alert("ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
          }
        },
        loop: function (currentTime) {
          Renderer.cacheBounds(); // æç”»é ˜åŸŸã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
          const dt = (currentTime - this.lastTime) / 1000;
          this.lastTime = currentTime;
          const safeDt = Math.min(dt, 0.1); // éåº¦ãªdeltaTimeã‚’é˜²æ­¢

          if (this.running) {
            const speedMultiplier = this.speed === 5 ? 10 : this.speed * 2;
            const scaledDt = safeDt * speedMultiplier;
            this.accTime += scaledDt;
            while (this.accTime >= this.tickDuration) {
              this.processTick();
              this.accTime -= this.tickDuration;
            }
            this.updateUnits(scaledDt); // Call updateUnits here
          }
          Renderer.update();
          requestAnimationFrame((t) => this.loop(t));
        },
        processTick: function () {
          this.day++;
          const tags = Object.keys(this.countries);

          if (this.day % 20 === 0) this.calcSupplyAll();

          // å›½å®¶ã”ã¨ã®å‡¦ç† (AIä»¥å¤–)
          tags.forEach((tag) => {
            if (tag === "_SEA") return;
            const c = this.countries[tag];
            if (c.provs.length === 0 && !c.dead) return;

            c.pp += (0.5 + c.fac / 50) * (1 + (c.ppGainBonus || 0));
            c.eq +=
              c.fac *
              15 *
              (1 + (c.facProdBonus || 0)) *
              (1 + (c.eqProdBonus || 0));
            if (c.eq > 200000) c.eq = 200000;
            c.peaceTimer = (c.peaceTimer || 0) + 1;
            if (c.xp > 500) c.xp = 500;
            c.xp += 0.05;

            if (c.focus) {
              c.focusProg++;
              if (c.focusProg >= c.focus.cost) this.completeFocus(c);
            } else if (c.buildingFactory) {
              c.buildingFactory.progress += 1 + (c.factoryBuildSpeedBonus || 0);
              if (c.buildingFactory.progress >= c.buildingFactory.cost) {
                c.fac++;
                c.pp -= 20;
                if (tag === this.player)
                  UI.notify(`${c.name} ã§å·¥å ´ãŒå®Œæˆ`, "success");
                c.buildingFactory = null;
              }
            }
            if (this.day % 30 === 0 && c.mp < 1e6) c.mp += c.fac * 100;
          });

          // AIå‡¦ç†ã‚’åˆ†æ•£ (1ãƒ•ãƒ¬ãƒ¼ãƒ ã«ã¤ã2ã‚«å›½ã ã‘å‡¦ç†)
          const aiBatchSize = 2;
          for (let i = 0; i < aiBatchSize; i++) {
            this.aiIndex = (this.aiIndex + 1) % tags.length;
            const tag = tags[this.aiIndex];
            if (tag !== this.player && tag !== "_SEA") {
              const c = this.countries[tag];
              if (c && c.fac > 0) AI.runCountry(tag);
            }
          }

          if (this.day % 100 === 0) {
            this.unitGrid.forEach((v, k) => {
              if (v.length === 0) this.unitGrid.delete(k);
            });
          }

          UI.update();
        },
        initCountries: function () {
          this.countries = {};
          if (this.geoData && this.geoData.features) {
            this.geoData.features.forEach((f) => {
              const props = f.properties;
              const name = props.nam_ja || props.nam || "Unknown";
              const id = props.id
                ? "P" + props.id
                : name.replace(/[^a-zA-Z0-9]/g, "");

              // åŸºæœ¬è¨­å®š
              this.countries[id] = {
                tag: id,
                name: name,
                col: nextColor(),
                flag: "ğŸ‡¯ğŸ‡µ",
                mp: 40000,
                fac: 3,
                eq: 1000,
                xp: 0,
                provs: [],
                pp: 50,
                st: 50,
                ws: 10,
                focus: null,
                focusProg: 0,
                completedFocuses: [],
                faction: null,
                template: DB.AITemplates.basic_inf, // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯åŸºæœ¬æ­©å…µ
                buildingFactory: null,
                treeType: "GENERIC",
                peaceTimer: 0,
                supplyMap: new Set(),
                ideology: "ä¸­ç«‹",
              };

              const c = this.countries[id];

              // === ã‚·ãƒŠãƒªã‚ªè¨­å®š ===

              // 1. ã‚°ãƒ³ãƒãƒ¼å¸å›½ (ãƒ‰ã‚¤ãƒ„æ )
              if (name.includes("Gunma") || name.includes("ç¾¤é¦¬")) {
                c.name = "ã‚°ãƒ³ãƒãƒ¼å¸å›½";
                c.flag = "ğŸ¦…";
                c.col = "#212121"; // ãƒ‰ã‚¤ãƒ„ã£ã½ã„é»’/ã‚°ãƒ¬ãƒ¼
                c.ideology = "å¸å›½ä¸»ç¾©";
                c.mp = 300000;
                c.fac = 20;
                c.treeType = "GUNMA";
                c.template = DB.AITemplates.tank_div; // åˆæœŸãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’æˆ¦è»Šå¸«å›£ã«
              }

              // 2. å¸æ”¿åƒè‘‰ (ã‚¤ã‚¿ãƒªã‚¢æ )
              else if (name.includes("Chiba") || name.includes("åƒè‘‰")) {
                c.name = "å¸æ”¿åƒè‘‰";
                c.flag = "ğŸ¥œ";
                c.col = "#2e7d32"; // ã‚¤ã‚¿ãƒªã‚¢ã£ã½ã„ç·‘
                c.ideology = "ãƒ•ã‚¡ã‚·ã‚ºãƒ ";
                c.fac = 12;
                c.faction = null;
              }

              // 3. æ ƒæœ¨ãƒ»èŒ¨åŸ (ãƒãƒ¼ãƒ©ãƒ³ãƒ‰æ )
              else if (name.includes("Tochigi") || name.includes("æ ƒæœ¨")) {
                c.name = "æ ƒæœ¨å…±å’Œå›½";
                c.flag = "ğŸ¥Ÿ";
                c.col = "#d81b60"; // ãƒãƒ¼ãƒ©ãƒ³ãƒ‰è‰²
                c.faction = "Kanto_Allies";
                c.treeType = "GENERIC"; // æ±ç”¨ã ãŒé˜²å¾¡å¯„ã‚ŠAIã«ã™ã‚‹
              } else if (name.includes("Ibaraki") || name.includes("èŒ¨åŸ")) {
                c.name = "èŒ¨åŸå…¬å›½";
                c.flag = "ğŸŒ¾";
                c.col = "#ad1457";
                c.faction = "Kanto_Allies";
              }

              // 4. åŸ¼ç‰ (ãƒ•ãƒ©ãƒ³ã‚¹æ )
              else if (name.includes("Saitama") || name.includes("åŸ¼ç‰")) {
                c.name = "åŸ¼ç‰ã‚³ãƒŸãƒ¥ãƒ¼ãƒ³";
                c.flag = "ğŸ•Šï¸";
                c.col = "#1565c0"; // ãƒ•ãƒ©ãƒ³ã‚¹é’
                c.ideology = "æ°‘ä¸»ä¸»ç¾©";
                c.fac = 15;
                c.mp = 150000;
                c.treeType = "SAITAMA";
                c.faction = "Kanto_Allies";
                c.st = 30; // æ”¿æ²»çš„ä¸å®‰å®š
              }

              // 5. æ±äº¬ (ã‚¤ã‚®ãƒªã‚¹æ )
              else if (name.includes("Tokyo") || name.includes("æ±äº¬")) {
                c.name = "å¸éƒ½æ±äº¬";
                c.flag = "ğŸ‘‘";
                c.col = "#b71c1c"; // ã‚¤ã‚®ãƒªã‚¹èµ¤
                c.ideology = "ç«‹æ†²å›ä¸»åˆ¶";
                c.fac = 25;
                c.mp = 200000;
                c.treeType = "TOKYO";
                c.faction = "Kanto_Allies";
                c.template = DB.AITemplates.elite_tank; // ã‚¨ãƒªãƒ¼ãƒˆæˆ¦è»Šå¸«å›£
              }

              // 6. ç¥å¥ˆå· (è¿½åŠ ï¼šé–¢æ±é€£åˆå…¥ã‚Š)
              else if (name.includes("Kanagawa") || name.includes("ç¥å¥ˆå·")) {
                c.name = "ç¥å¥ˆå·è‡ªç”±å›½";
                c.flag = "ğŸš¢";
                c.faction = "Kanto_Allies";
                c.fac = 18;
                c.col = "#0d47a1";
              }

              // 7. åŒ—æµ·é“ (ã‚½é€£æ )
              else if (name.includes("Hokkaido") || name.includes("åŒ—æµ·é“")) {
                c.name = "åŒ—æµ·ã‚½ãƒ“ã‚¨ãƒˆ";
                c.flag = "â˜­";
                c.col = "#880e4f"; // ã‚½é€£ã®æ¿ƒã„èµ¤
                c.ideology = "å…±ç”£ä¸»ç¾©";
                c.fac = 30;
                c.mp = 500000;
                c.treeType = "HOKKAIDO";
                c.template = DB.AITemplates.mech_div; // æ©Ÿæ¢°åŒ–å¸«å›£
              }

              // 8. æ±åŒ— (ãƒãƒ«ãƒˆä¸‰å›½æ )
              else if (
                [
                  "Aomori",
                  "Iwate",
                  "Akita",
                  "Miyagi",
                  "Yamagata",
                  "Fukushima",
                ].some((n) => name.includes(n)) ||
                ["é’æ£®", "å²©æ‰‹", "ç§‹ç”°", "å®®åŸ", "å±±å½¢", "ç¦å³¶"].some((n) =>
                  name.includes(n)
                )
              ) {
                c.treeType = "GENERIC";
                c.territoryDefBonus = 0.5; // é˜²å¾¡ãƒœãƒ¼ãƒŠã‚¹ç‰¹ç››
                c.col = "#546e7a"; // ãƒãƒ«ãƒˆã£ã½ã„è‰²
              }

              // 9. è¥¿æ—¥æœ¬ãƒ»å››å›½ (ãƒãƒˆãƒ­ãƒ¯)
              else if (
                ["Kagawa", "Tokushima", "Ehime", "Kochi"].some((n) =>
                  name.includes(n)
                ) ||
                ["é¦™å·", "å¾³å³¶", "æ„›åª›", "é«˜çŸ¥"].some((n) => name.includes(n))
              ) {
                c.treeType = "GENERIC_WAR"; // æˆ¦äº‰ãƒ„ãƒªãƒ¼
                c.ideology = "ç¾¤é›„å‰²æ‹ ";
              }

              // 10. ä¹å· (å¾æœç‹™ã„)
              else if (
                ["Fukuoka", "Kumamoto", "Kagoshima"].some((n) =>
                  name.includes(n)
                ) ||
                ["ç¦å²¡", "ç†Šæœ¬", "é¹¿å…å³¶"].some((n) => name.includes(n))
              ) {
                c.name = name.includes("Fukuoka") ? "ä¿®ç¾…ã®å›½" : c.name;
                c.treeType = "GENERIC_WAR";
                c.fac += 5;
                c.mp += 50000;
                c.template = DB.AITemplates.bike_div; // æ©Ÿå‹•åŠ›é‡è¦–ã®è‡ªè»¢è»Šå¸«å›£
              }

              // 11. é–¢è¥¿ãƒ»æ„›çŸ¥ (è¥¿æ—¥æœ¬å¾æœ)
              else if (
                ["Osaka", "Kyoto", "Aichi"].some((n) => name.includes(n)) ||
                ["å¤§é˜ª", "äº¬éƒ½", "æ„›çŸ¥"].some((n) => name.includes(n))
              ) {
                c.treeType = "GENERIC_WAR";
                c.fac += 8;
                c.mp += 100000;
              }

              // 12. çŸ³å· (åŒ—é™¸å¾æœ)
              else if (name.includes("Ishikawa") || name.includes("çŸ³å·")) {
                c.name = "åŠ è³€ç™¾ä¸‡çŸ³";
                c.treeType = "GENERIC_WAR";
                c.fac += 5;
              }
            });
          }
        },
        justifyWar: function () {
          if (this.selected && this.selected !== this.player) {
            const target = this.selected; // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’å¤‰æ•°ã«ä¿å­˜
            UI.notify(`å·¥ä½œå“¡ã‚’æ´¾é£ä¸­... (${Game.countries[target].name}ã¸)`);
            setTimeout(() => this.declareWar(this.player, target), 2000);
          }
        },
        justifyWarTarget: function (targetName, myTag) {
          const targetTag = Object.keys(Game.countries).find((t) =>
            Game.countries[t].name.includes(targetName)
          );
          if (targetTag) {
            Game.declareWar(myTag, targetTag);
          }
        },
        calcStats: function (tmpl) {
          let s = {
            sa: 0,
            ha: 0,
            def: 0,
            brk: 0,
            arm: 0,
            prc: 0,
            org: 0,
            spd: 999,
            cost: 0,
          };
          if (!tmpl || !tmpl.bat.length) return s;
          let batCount = 0;
          tmpl.bat.forEach((t) => {
            const d = DB.UnitTypes[t];
            if (!d) return;
            s.sa += d.sa;
            s.ha += d.ha;
            s.def += d.def;
            s.brk += d.brk;
            s.cost += d.cost;
            s.org += d.org;
            if (d.arm > s.arm) s.arm = d.arm * 0.3 + s.arm * 0.7;
            if (d.prc > s.prc) s.prc = d.prc * 0.4 + s.prc * 0.6;
            if (d.spd < s.spd) s.spd = d.spd;
            batCount++;
          });
          if (batCount > 0) s.org /= batCount;
          else s.spd = 0;
          tmpl.sup.forEach((t) => {
            const d = DB.UnitTypes[t];
            if (!d) return;
            s.sa += d.sa;
            s.ha += d.ha;
            s.def += d.def;
            s.brk += d.brk;
            s.cost += d.cost;
          });
          let maxArm = 0;
          tmpl.bat.forEach((t) => {
            if (DB.UnitTypes[t].arm > maxArm) maxArm = DB.UnitTypes[t].arm;
          });
          s.arm = (s.arm + maxArm) / 2;
          return s;
        },
        spawnInitialUnits: function () {
          Object.values(this.countries).forEach((c) => {
            if (c.tag === "_SEA") return;
            const n = Math.min(20, Math.max(3, ~~(c.fac / 1.5)));
            for (let i = 0; i < n; i++)
              if (c.provs.length) this.spawnUnit(c.tag, c.capital, c.template);
          });
        },
        spawnUnit: function (tag, hex, template) {
          if (!hex) return;
          const tmplCopy = { bat: [...template.bat], sup: [...template.sup] };
          const stats = this.calcStats(tmplCopy);
          const u = {
            id: Math.random().toString(36),
            tag: tag,
            x: hex.x,
            y: hex.y,
            hex: hex,
            state: "idle",
            path: [],
            hp: 100,
            org: stats.org,
            maxOrg: stats.org,
            template: tmplCopy,
            stats: stats,
            icon: DB.UnitTypes[tmplCopy.bat[0]].icon,
            lastRenderX: 0,
            lastRenderY: 0,
            lastHpW: 0,
            lastOrgW: 0,
            isFighting: false,
            supply: 100,
          };
          this.units.push(u);
          this.addToGrid(u, hex);
          Renderer.addUnit(u);
        },
        addToGrid: function (unit, hex) {
          if (!this.unitGrid.has(hex.id)) {
            this.unitGrid.set(hex.id, []);
          }
          this.unitGrid.get(hex.id).push(unit);
        },

        removeFromGrid: function (unit, hex) {
          if (this.unitGrid.has(hex.id)) {
            const unitsInHex = this.unitGrid.get(hex.id);
            const index = unitsInHex.indexOf(unit);
            if (index > -1) {
              unitsInHex.splice(index, 1);
            }
            if (unitsInHex.length === 0) {
              this.unitGrid.delete(hex.id);
            }
          }
        },

        getEnemyInHex: function (hex, myTag) {
          if (!this.unitGrid.has(hex.id)) return null;
          const units = this.unitGrid.get(hex.id);
          return units.find((u) => u.tag !== myTag && this.isWar(myTag, u.tag));
        },

        updateUnits: function (dt) {
          const moveSpeed = 50;
          const unitMoveFactor = 0.5;

          for (let i = this.units.length - 1; i >= 0; i--) {
            const u = this.units[i];
            if (!u.el) continue;

            // Supply decay
            u.supply -= 0.05 * dt;
            if (u.supply < 0) u.supply = 0;

            // Organization recovery
            if (u.org < u.maxOrg) {
              u.org += 0.5 * dt;
              if (u.org > u.maxOrg) u.org = u.maxOrg;
            }

            // Remove dead units
            if (u.hp <= 0) {
              this.removeFromGrid(u, u.hex);
              u.el.remove();
              this.units.splice(i, 1);
              Input.selUnits = Input.selUnits.filter((su) => su !== u);
              if (u.tag === this.player) {
                UI.notify(`æˆ‘ãŒè»ã®å¸«å›£ãŒå£Šæ»…ã—ã¾ã—ãŸï¼`, "danger");
              }
              continue;
            }

            // Movement
            if (u.state === "moving" && u.path.length > 0) {
              const nextHex = u.path[0];
              const distToTarget = Math.hypot(nextHex.x - u.x, nextHex.y - u.y);
              const actualMoveSpeed =
                (moveSpeed + u.stats.spd * unitMoveFactor) * dt;

              if (distToTarget <= actualMoveSpeed) {
                u.x = nextHex.x;
                u.y = nextHex.y;

                this.removeFromGrid(u, u.hex);
                u.hex = nextHex;
                this.addToGrid(u, u.hex);

                u.path.shift();

                // Conquest (æˆ¦äº‰ä¸­ã‹ã©ã†ã‹ã«ã‹ã‹ã‚ã‚‰ãšã€ä»–å›½é ˜ãªã‚‰å é ˜)
                if (u.hex.owner !== u.tag && u.hex.owner !== "_SEA") {
                  this.conquerHex(u, u.hex);
                  if (u.tag === this.player) {
                    UI.notify(
                      `${this.countries[u.hex.owner].name} ã®é ˜åœŸã‚’å é ˜ï¼`,
                      "success"
                    );
                  }
                }

                // Battle Check
                const enemyUnits = this.unitGrid
                  .get(u.hex.id)
                  ?.filter(
                    (eu) => eu.tag !== u.tag && this.isWar(u.tag, eu.tag)
                  );
                if (enemyUnits && enemyUnits.length > 0) {
                  u.state = "fighting";
                  u.innerEl.classList.add("fighting");
                  enemyUnits.forEach((eu) => {
                    eu.state = "fighting";
                    eu.innerEl.classList.add("fighting");
                  });
                }

                if (u.path.length === 0) {
                  u.state = "idle";
                  u.innerEl.classList.remove("fighting");
                }
              } else {
                const angle = Math.atan2(nextHex.y - u.y, nextHex.x - u.x);
                u.x += Math.cos(angle) * actualMoveSpeed;
                u.y += Math.sin(angle) * actualMoveSpeed;
              }
            }

            // Battle simulation
            const unitsInHex = this.unitGrid.get(u.hex.id);
            if (u.state === "fighting" && unitsInHex && unitsInHex.length > 1) {
              this.battle(u.hex);
            } else if (
              u.state === "fighting" &&
              (!unitsInHex ||
                unitsInHex.filter(
                  (eu) => eu.tag !== u.tag && this.isWar(u.tag, eu.tag)
                ).length === 0)
            ) {
              u.state = "idle";
              u.innerEl.classList.remove("fighting");
            }

            // Apply supply effects
            if (u.supply < 30) {
              u.org -= 1 * dt;
              if (u.org < 0) u.org = 0;
            }

            Renderer.updateUnit(u);
          }
        },

        battle: function (hex) {
          const unitsInHex = this.unitGrid.get(hex.id);
          if (!unitsInHex || unitsInHex.length < 2) return;

          const factions = {};
          unitsInHex.forEach((u) => {
            if (!factions[u.tag]) factions[u.tag] = [];
            factions[u.tag].push(u);
          });

          const tags = Object.keys(factions);
          if (tags.length < 2) return;

          let attackerTag = null;
          let defenderTag = null;
          for (let i = 0; i < tags.length; i++) {
            for (let j = i + 1; j < tags.length; j++) {
              if (this.isWar(tags[i], tags[j])) {
                attackerTag = tags[i];
                defenderTag = tags[j];
                break;
              }
            }
            if (attackerTag) break;
          }

          if (!attackerTag || !defenderTag) return;

          const attackers = factions[attackerTag];
          const defenders = factions[defenderTag];

          const getCombinedStats = (units) => {
            let sa = 0,
              ha = 0,
              def = 0,
              brk = 0,
              arm = 0,
              org = 0,
              count = 0;
            units.forEach((u) => {
              if (u.hp > 0) {
                sa += u.stats.sa;
                ha += u.stats.ha;
                def += u.stats.def;
                brk += u.stats.brk;
                arm += u.stats.arm;
                org += u.org;
                count++;
              }
            });
            return {
              sa,
              ha,
              def,
              brk,
              arm,
              org: count > 0 ? org / count : 0,
              count,
            };
          };

          const attStats = getCombinedStats(attackers);
          const defStats = getCombinedStats(defenders);

          if (attStats.count === 0 || defStats.count === 0) {
            unitsInHex.forEach((u) => {
              u.state = "idle";
              u.innerEl.classList.remove("fighting");
            });
            return;
          }

          let defBonus = 1;
          if (hex.owner === defenderTag) {
            defBonus += this.countries[defenderTag].territoryDefBonus || 0;
          }

          const attOrgFactor = Math.max(0.1, attStats.org / 100);
          const defOrgFactor = Math.max(0.1, defStats.org / 100);

          let attackPower = attStats.sa * attOrgFactor;
          let defensePower = defStats.def * defOrgFactor * defBonus;

          let guaranteedDmg = Math.max(5, attackPower * 0.2);
          let breakDmg = Math.max(0, attackPower - defensePower) * 0.8;

          let counterAttackPower = defStats.sa * defOrgFactor;
          let counterBreakthrough = attStats.brk * attOrgFactor;
          let guaranteedCounterDmg = Math.max(2, counterAttackPower * 0.15);
          let counterBreakDmg =
            Math.max(0, counterAttackPower - counterBreakthrough) * 0.5;

          const totalDmgToDef = (guaranteedDmg + breakDmg) * 0.5;
          const totalDmgToAtt = (guaranteedCounterDmg + counterBreakDmg) * 0.5;

          defenders.forEach((u) => {
            u.org -= totalDmgToDef / defenders.length;
            u.hp -= (totalDmgToDef * 0.1) / defenders.length;

            if (u.org <= 0) {
              u.org = 0;
              const safeHex = u.hex.adj.find(
                (n) =>
                  n.owner === u.tag &&
                  !this.unitGrid.get(n.id)?.some((eu) => eu.tag !== u.tag)
              );
              if (safeHex) {
                u.path = [safeHex];
                u.state = "moving";
                u.org = 10;
              } else {
                u.hp = 0;
              }
            }
          });

          attackers.forEach((u) => {
            u.org -= totalDmgToAtt / attackers.length;
            u.hp -= (totalDmgToAtt * 0.1) / attackers.length;
            if (u.org < 0) u.org = 0;
          });

          const remainingAttackers = attackers.filter(
            (u) => u.hp > 0 && u.state === "fighting"
          );
          const remainingDefenders = defenders.filter(
            (u) => u.hp > 0 && u.state === "fighting"
          );

          if (remainingAttackers.length === 0) {
            defenders.forEach((u) => {
              if (u.state === "fighting") u.state = "idle";
              u.innerEl.classList.remove("fighting");
            });
          } else if (remainingDefenders.length === 0) {
            // ã€ä¿®æ­£ã€‘æ”»æ’ƒæˆåŠŸæ™‚ã€ç›´ã¡ã«é€²è»ã‚’é–‹å§‹
            attackers.forEach((u) => {
              u.innerEl.classList.remove("fighting");
              u.path = [hex]; // æˆ¦é—˜ã—ã¦ã„ãŸå ´æ‰€ã¸ç§»å‹•
              u.state = "moving";
            });
          } else {
            attackers.forEach((u) => u.innerEl.classList.add("fighting"));
            defenders.forEach((u) => u.innerEl.classList.add("fighting"));
          }
        },
        recruit: function () {
          const c = this.countries[this.player];
          const stats = this.calcStats(c.template);
          const armySize = this.units.filter(
            (u) => u.tag === this.player
          ).length;
          const maxArmy = Math.min(~~(c.fac * 2.5 + 5), 100);
          if (armySize >= maxArmy) {
            UI.notify(`å¸«å›£ä¸Šé™ã§ã™ (ç¾åœ¨:${armySize}/${maxArmy})`, "warn");
            return;
          }
          const actualEqCost = stats.cost;
          if (c.mp >= 1000 && c.eq >= actualEqCost) {
            c.mp -= 1000;
            c.eq -= actualEqCost;
            if (c.provs.length) {
              this.spawnUnit(this.player, c.capital, c.template);
              UI.notify("å¸«å›£ç·¨æˆå®Œäº†");
            }
          } else {
            UI.notify(
              `è³‡æºä¸è¶³ (å¿…è¦: äººçš„1000, è£…å‚™${actualEqCost.toFixed(0)})`,
              "warn"
            );
          }
        },
        buildFactory: function () {
          const c = this.countries[this.player];
          if (c.focus) {
            UI.notify("å›½å®¶æ–¹é‡å®Ÿè¡Œä¸­ã¯å·¥å ´ã‚’å»ºè¨­ã§ãã¾ã›ã‚“ã€‚", "warn");
            return;
          }
          if (c.buildingFactory) {
            UI.notify("æ—¢ã«å·¥å ´ã‚’å»ºè¨­ä¸­ã§ã™ã€‚", "warn");
            return;
          }
          if (c.pp < 50) {
            UI.notify("æ”¿æ²»åŠ›ãŒè¶³ã‚Šã¾ã›ã‚“ (50å¿…è¦)ã€‚", "warn");
            return;
          }
          c.pp -= 50;
          c.buildingFactory = { cost: 10, progress: 0, name: "çœŒå–¶å·¥å ´å»ºè¨­" };
          UI.notify("çœŒå–¶å·¥å ´ã®å»ºè¨­ã‚’é–‹å§‹ã—ã¾ã—ãŸ", "success");
          UI.update();
        },

        calcSupplyAll: function () {
          Object.values(this.countries).forEach((c) => {
            if (c.tag === "_SEA" || c.dead || !c.capital) return;
            c.supplyMap.clear();
            const queue = [c.capital];
            c.supplyMap.add(c.capital.id);
            const visited = new Set([c.capital.id]);
            while (queue.length > 0) {
              const curr = queue.shift();
              curr.adj.forEach((n) => {
                if (n.owner === c.tag && !visited.has(n.id)) {
                  visited.add(n.id);
                  c.supplyMap.add(n.id);
                  queue.push(n);
                }
              });
            }
          });
          this.units.forEach((u) => {
            const c = this.countries[u.tag];
            if (c && c.supplyMap.has(u.hex.id)) {
              u.supply = 100;
            }
          });
        },

        calcCapitals: function () {
          Object.values(this.countries).forEach((c) => {
            if (c.tag === "_SEA") return;
            if (c.provs.length === 0) {
              if (c.capIcon) {
                c.capIcon.remove();
                c.capIcon = null;
              }
              c.capital = null;
              return;
            }
            if (c.capital && c.provs.includes(c.capital)) {
              if (!c.capIcon) {
                const t = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "text"
                );
                t.textContent = "â˜…";
                t.setAttribute("fill", "gold");
                t.setAttribute(
                  "style",
                  "pointer-events:none;font-size:18px;font-weight:bold;text-shadow:0 0 2px #000"
                );
                $("game-svg").appendChild(t);
                c.capIcon = t;
              }
              c.capIcon.setAttribute("x", c.capital.x - 9);
              c.capIcon.setAttribute("y", c.capital.y + 6);
              return;
            }
            let best = c.provs[0];
            const fixed =
              CapitalCoords[c.tag] ||
              (c.name.includes("Tokyo") ? CapitalCoords["P13"] : null);
            if (fixed) {
              let minD = Infinity;
              c.provs.forEach((p) => {
                const d = (p.lat - fixed.lat) ** 2 + (p.lon - fixed.lon) ** 2;
                if (d < minD) {
                  minD = d;
                  best = p;
                }
              });
            } else {
              let cx = 0,
                cy = 0;
              c.provs.forEach((p) => {
                cx += p.gx;
                cy += p.gy;
              });
              cx /= c.provs.length;
              cy /= c.provs.length;
              let minD = Infinity;
              c.provs.forEach((p) => {
                const d = (p.gx - cx) ** 2 + (p.gy - cy) ** 2;
                if (d < minD) {
                  minD = d;
                  best = p;
                }
              });
            }
            c.capital = best;
            if (!c.capIcon) {
              const t = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              t.textContent = "â˜…";
              t.setAttribute("fill", "gold");
              t.setAttribute(
                "style",
                "pointer-events:none;font-size:18px;font-weight:bold;text-shadow:0 0 2px #000"
              );
              $("game-svg").appendChild(t);
              c.capIcon = t;
            }
            c.capIcon.setAttribute("x", best.x - 9);
            c.capIcon.setAttribute("y", best.y + 6);
          });
        },
        conquerHex: function (u, h) {
          const oldOwner = h.owner;
          if (oldOwner === u.tag) return;
          const oc = this.countries[oldOwner];
          const nc = this.countries[u.tag];
          if (h.factories > 0) {
            nc.fac += h.factories;
            if (oc) oc.fac -= h.factories;
          }
          if (oc) oc.provs = oc.provs.filter((x) => x !== h);
          h.owner = u.tag;
          h.el.setAttribute("fill", nc.col);
          nc.provs.push(h);
          if (oc && oc.capital === h) {
            UI.notify(`${nc.name} ãŒ ${oc.name} ã®çœŒåºæ‰€åœ¨åœ°ã‚’åˆ¶åœ§ï¼`, "war");
            oc.ws -= 50;
            if (oc.ws < 20) {
              this.capitulate(oldOwner, u.tag);
            } else {
              this.calcCapitals();
            }
          } else {
            this.calcCapitals();
          }
          this.calcSupplyAll();
        },
        capitulate: function (loser, winner) {
          const lc = this.countries[loser];
          const wc = this.countries[winner];
          SuperEvent.trigger(
            "çœŒåºé™¥è½",
            `${lc.name} æ”¿åºœãŒé™ä¼ã€‚\nå…¨åœŸã¯ ${wc.name} ã®çœŒæ”¿ä¸‹ã«ç½®ã‹ã‚Œã‚‹ã€‚`,
            "ãƒ‹ãƒ¥ãƒ¼ã‚¹é€Ÿå ±",
            "ğŸ³ï¸",
            lc.col,
            "è«¸è¡Œç„¡å¸¸ã€‚"
          );
          [...lc.provs].forEach((p) => {
            p.owner = winner;
            p.el.setAttribute("fill", wc.col);
            wc.provs.push(p);
            wc.fac += p.factories;
          });
          lc.fac = 0;
          lc.provs = [];
          lc.dead = true;
          this.units = this.units.filter((u) => u.tag !== loser);
          document.querySelectorAll(".unit-grp").forEach((el) => {
            const uObj = this.units.find((x) => x.el === el);
            if (!uObj) el.remove();
          });
          this.unitGrid.forEach((v, k) => {
            this.unitGrid.set(
              k,
              v.filter((u) => u.tag !== loser)
            );
          });
          this.wars = this.wars.filter(
            (w) => w.atk !== loser && w.def !== loser
          );
          this.calcCapitals();
          this.calcSupplyAll();
        },
        declareWar: function (a, b) {
          if (this.isWar(a, b) || this.isAlly(a, b)) return;
          this.wars.push({ atk: a, def: b });
          this.tension += 2;
          if (this.countries[a]) this.countries[a].peaceTimer = 0;
          if (this.countries[b]) this.countries[b].peaceTimer = 0;

          const isPlayerInvolved = a === this.player || b === this.player;
          const isMajorWar =
            this.countries[a].fac >= 10 && this.countries[b].fac >= 10;

          if (isPlayerInvolved || isMajorWar) {
            UI.notify(
              `${this.countries[a].name} ãŒ ${this.countries[b].name} ã«å®£æˆ¦å¸ƒå‘Šï¼`,
              "war"
            );
          }

          if (
            this.tension > 80 &&
            this.day - this.lastSuperEventDay > 365 &&
            (isPlayerInvolved || isMajorWar)
          ) {
            const enemy = a === this.player ? b : a;
            const cName = this.countries[enemy].name;
            const title = "æˆ¦å›½æ™‚ä»£ å‹ƒç™º";
            const quote =
              "ã‚µã‚¤ã¯æŠ•ã’ã‚‰ã‚ŒãŸã€‚\nå¹³å’Œæ†²æ³•ã¯éå»ã®ã‚‚ã®ã¨ãªã‚Šã€åˆ—å³¶ã¯å†ã³ç‚ã«åŒ…ã¾ã‚Œã‚‹ã€‚";
            SuperEvent.trigger(
              title,
              quote,
              `${cName} çœŒçŸ¥äº‹å£°æ˜`,
              "âš”ï¸",
              "#200",
              "ã„ã–ã€å‡ºé™£ã€‚"
            );
            this.lastSuperEventDay = this.day;
          }

          if (Game.selected === b) UI.updateSidebar();
        },
        isWar: function (a, b) {
          return this.wars.some(
            (w) => (w.atk === a && w.def === b) || (w.atk === b && w.def === a)
          );
        },
        isAlly: function (tag1, tag2) {
          if (!this.countries[tag1] || !this.countries[tag2]) return false;
          const f1 = this.countries[tag1].faction;
          const f2 = this.countries[tag2].faction;
          return f1 && f2 && f1 === f2;
        },
        getAliveCountryCount: function () {
          return Object.keys(this.countries).filter(
            (k) => k !== "_SEA" && !this.countries[k].dead
          ).length;
        },
        startFocus: function (fid) {
          const c = this.countries[this.player];
          if (c.buildingFactory) {
            UI.notify("å»ºè¨­ä¸­ã¯çœŒæ”¿æ–¹é‡ã‚’é–‹å§‹ã§ãã¾ã›ã‚“ã€‚", "warn");
            return;
          }
          const tree = DB.FocusTree[c.treeType] || DB.FocusTree.GENERIC;
          const f = tree.find((x) => x.id === fid);
          if (f && c.pp >= f.cost) {
            c.focus = f;
            c.focusProg = 0;
            UI.updateFocusModal();
          }
        },
        completeFocus: function (c) {
          c.focus.eff(c);
          c.completedFocuses.push(c.focus.id);
          if (c.tag === this.player) {
            UI.notify(`${c.focus.t} å®Œäº†`, "success");
            UI.closeFocusTree();
          }
          c.focus = null;
        },
        setSpeed: function (s) {
          this.speed = s;
          this.running = s > 0;
          document
            .querySelectorAll(".spd-btn")
            .forEach((b, i) =>
              b.classList.toggle("active", [0, 1, 3, 5].indexOf(s) === i)
            );
        },
        getNeighbors: function (tag) {
          const c = this.countries[tag];
          if (!c) return [];
          const neighbors = new Set();
          c.provs.forEach((p) => {
            p.adj.forEach((a) => {
              if (a.owner !== "_SEA" && a.owner !== tag) neighbors.add(a.owner);
            });
          });
          return Array.from(neighbors);
        },
        getFrontlineHexes: function (tag) {
          const c = this.countries[tag];
          if (!c) return [];
          return c.provs.filter((p) =>
            p.adj.some(
              (a) =>
                a.owner !== "_SEA" &&
                a.owner !== tag &&
                this.isWar(tag, a.owner)
            )
          );
        },
        initMap: function () {
          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg"
          );
          svg.id = "game-svg";
          svg.setAttribute("width", "100%");
          svg.setAttribute("height", "100%");
          svg.setAttribute("overflow", "visible");
          svg.style.transformOrigin = "0 0";
          svg.style.willChange = "transform";
          const defs = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "defs"
          );
          defs.innerHTML =
            '<filter id="glow"><feGaussianBlur stdDeviation="2" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
          svg.appendChild(defs);
          Input.mapWrapEl.appendChild(svg);

          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;
          this.geoData.features.forEach((f) => {
            f.geometry.coordinates.forEach((poly) => {
              const rings = f.geometry.type === "MultiPolygon" ? poly : [poly];
              rings.forEach((ring) => {
                const arr = f.geometry.type === "MultiPolygon" ? ring : rings;
                const points = Array.isArray(arr[0][0]) ? arr.flat() : arr;
                points.forEach((p) => {
                  const x = p[0];
                  const y = p[1];
                  if (x < minX) minX = x;
                  if (x > maxX) maxX = x;
                  if (y < minY) minY = y;
                  if (y > maxY) maxY = y;
                });
              });
            });
          });
          minX -= 1;
          maxX += 1;
          minY -= 1;
          maxY += 1;
          const mapScale = 120;
          const R = 22;
          const mapPixelWidth = (maxX - minX) * mapScale * 1.5;
          const mapPixelHeight = (maxY - minY) * mapScale * 1.8;
          const cols = Math.ceil(mapPixelWidth / (R * 1.5));
          const rows = Math.ceil(mapPixelHeight / (R * 1.732));

          MapSys.hexes = [];
          const isInside = (point, vs) => {
            let x = point[0],
              y = point[1];
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
              let xi = vs[i][0],
                yi = vs[i][1];
              let xj = vs[j][0],
                yj = vs[j][1];
              let intersect =
                yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
              if (intersect) inside = !inside;
            }
            return inside;
          };

          const featureBBoxes = this.geoData.features.map((f) => {
            let minLon = Infinity,
              minLat = Infinity,
              maxLon = -Infinity,
              maxLat = -Infinity;
            const processCoords = (coords) => {
              coords.forEach((p) => {
                const lon = p[0];
                const lat = p[1];
                minLon = Math.min(minLon, lon);
                minLat = Math.min(minLat, lat);
                maxLon = Math.max(maxLon, lon);
                maxLat = Math.max(maxLat, lat);
              });
            };

            const polyType = f.geometry.type;
            const coords = f.geometry.coordinates;
            if (polyType === "Polygon") {
              coords.forEach((ring) => processCoords(ring));
            } else if (polyType === "MultiPolygon") {
              coords.forEach((poly) =>
                poly.forEach((ring) => processCoords(ring))
              );
            }
            return { feature: f, bbox: { minLon, minLat, maxLon, maxLat } };
          });

          for (let gy = 0; gy < rows; gy++) {
            for (let gx = 0; gx < cols; gx++) {
              const x = gx * R * 1.5 + 25;
              const y = gy * R * 1.732 + 25 + (gx % 2 ? R * 0.866 : 0);
              const lon = x / (mapScale * 1.5) + minX;
              const lat = maxY - y / (mapScale * 1.8);
              let owner = "_SEA";

              for (const fb of featureBBoxes) {
                const bbox = fb.bbox;
                if (
                  lon >= bbox.minLon &&
                  lon <= bbox.maxLon &&
                  lat >= bbox.minLat &&
                  lat <= bbox.maxLat
                ) {
                  let inside = false;
                  const f = fb.feature;
                  const props = f.properties;
                  const polyType = f.geometry.type;
                  const coords = f.geometry.coordinates;
                  if (polyType === "Polygon") {
                    coords.forEach((ring) => {
                      if (isInside([lon, lat], ring)) inside = true;
                    });
                  } else if (polyType === "MultiPolygon") {
                    coords.forEach((poly) => {
                      poly.forEach((ring) => {
                        if (isInside([lon, lat], ring)) inside = true;
                      });
                    });
                  }
                  if (inside) {
                    const name = props.nam_ja || props.nam;
                    const id = props.id
                      ? "P" + props.id
                      : name.replace(/[^a-zA-Z0-9]/g, "");
                    owner = id;
                    break;
                  }
                }
              }

              const hexEl = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "polygon"
              );
              const points = [];
              for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                points.push(
                  `${x + R * Math.cos(angle)},${y + R * Math.sin(angle)}`
                );
              }
              hexEl.setAttribute("points", points.join(" "));
              hexEl.setAttribute("class", owner === "_SEA" ? "hex sea" : "hex");
              hexEl.dataset.id = MapSys.hexes.length;

              if (owner !== "_SEA") {
                const c = this.countries[owner];
                if (c) {
                  hexEl.setAttribute("fill", c.col);
                  this.countries[owner].provs.push({
                    id: MapSys.hexes.length,
                    gx,
                    gy,
                    x,
                    y,
                    lon,
                    lat,
                    el: hexEl,
                    adj: [],
                    owner: owner,
                    type: "plains",
                    factories: 0,
                  });
                  const h =
                    this.countries[owner].provs[
                      this.countries[owner].provs.length - 1
                    ];
                  MapSys.hexes.push(h);
                  svg.appendChild(hexEl);
                  if (Math.random() < 0.05) {
                    h.factories = 1;
                    c.fac++;
                  }
                }
              } else {
                svg.appendChild(hexEl);
                MapSys.hexes.push({
                  id: MapSys.hexes.length,
                  gx,
                  gy,
                  x,
                  y,
                  lon,
                  lat,
                  el: hexEl,
                  adj: [],
                  owner: "_SEA",
                  type: "sea",
                  factories: 0,
                });
              }
            }
          }
          const gridMap = {};
          MapSys.hexes.forEach((h) => (gridMap[`${h.gx},${h.gy}`] = h));
          MapSys.hexes.forEach((a) => {
            const isOdd = a.gx % 2 === 1;
            const offsets = isOdd
              ? [
                  [0, -1],
                  [0, 1],
                  [-1, 0],
                  [-1, 1],
                  [1, 0],
                  [1, 1],
                ]
              : [
                  [0, -1],
                  [0, 1],
                  [-1, -1],
                  [-1, 0],
                  [1, -1],
                  [1, 0],
                ];
            offsets.forEach((o) => {
              const k = `${a.gx + o[0]},${a.gy + o[1]}`;
              if (gridMap[k]) a.adj.push(gridMap[k]);
            });
          });
          Renderer.layer = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );
          svg.appendChild(Renderer.layer);
          Renderer.uiLayer = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );
          svg.appendChild(Renderer.uiLayer);

          if (!document.getElementById("arrowhead")) {
            const defs = $("game-svg").querySelector("defs");
            const marker = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "marker"
            );
            marker.setAttribute("id", "arrowhead");
            marker.setAttribute("markerWidth", "10");
            marker.setAttribute("markerHeight", "7");
            marker.setAttribute("refX", "9");
            marker.setAttribute("refY", "3.5");
            marker.setAttribute("orient", "auto");
            marker.innerHTML =
              '<polygon points="0 0, 10 3.5, 0 7" fill="#ffca28" />';
            defs.appendChild(marker);
          }

          this.calcCapitals();
          Renderer.s = 0.6;
          const screenCX = Input.mapWrapEl.offsetWidth / 2;
          const screenCY = Input.mapWrapEl.offsetHeight / 2;
          Renderer.x = screenCX - 800 * Renderer.s;
          Renderer.y = screenCY - 600 * Renderer.s;
          Renderer.update();
        },
      };
      const AI = {
        runCountry: function (tag) {
          const c = Game.countries[tag];
          if (!c || c.provs.length === 0 || c.dead) return;

          // 1. å†…æ”¿ (å¤‰æ›´ãªã—)
          if (!c.focus && !c.buildingFactory) {
            const tree = DB.FocusTree[c.treeType] || DB.FocusTree.GENERIC;
            const available = tree.filter(
              (f) =>
                !c.completedFocuses.includes(f.id) &&
                f.req.every((r) => c.completedFocuses.includes(r)) &&
                (!f.mut || !f.mut.some((m) => c.completedFocuses.includes(m)))
            );
            if (available.length > 0) {
              c.focus = available[Math.floor(Math.random() * available.length)];
              c.focusProg = 0;
            } else if (c.pp >= 70 && Math.random() < 0.2) {
              c.pp -= 50;
              c.buildingFactory = {
                cost: 10,
                progress: 0,
                name: "çœŒå–¶å·¥å ´å»ºè¨­",
              };
            }
          }

          // 2. å¾´å…µ (å¤‰æ›´ãªã—)
          const myUnits = Game.units.filter((u) => u.tag === tag);
          const armyLimit = 40 + Math.floor(c.fac / 2);
          const enemies = Game.wars
            .filter((w) => w.atk === tag || w.def === tag)
            .map((w) => (w.atk === tag ? w.def : w.atk));

          if (
            c.mp > 1500 &&
            myUnits.length < armyLimit &&
            (enemies.length > 0 || Math.random() < 0.1)
          ) {
            let targetTmpl = DB.AITemplates.basic_inf;
            if (c.treeType === "GUNMA") targetTmpl = DB.AITemplates.tank_div;

            const stats = Game.calcStats(targetTmpl);
            if (c.eq >= stats.cost) {
              c.mp -= 1000;
              c.eq -= stats.cost;
              Game.spawnUnit(tag, c.capital, targetTmpl);
            }
          }

          // 3. æˆ¦ç•¥AI (ä¿®æ­£ç‰ˆ: é è·é›¢ç§»å‹•ã®å®Ÿè£…)
          const isBlitzCountry = c.treeType === "GUNMA";

          let actions = 0;
          const maxActions = 10; // 1ã‚¿ãƒ¼ãƒ³ã«å‘½ä»¤ã‚’å‡ºã™ãƒ¦ãƒ‹ãƒƒãƒˆæ•°åˆ¶é™ï¼ˆè² è·è»½æ¸›ï¼‰

          // æ•µå›½ã®ã‚¿ã‚°ã‚’å–å¾—
          const targetTags = Game.wars
            .filter((w) => w.atk === tag || w.def === tag)
            .map((w) => (w.atk === tag ? w.def : w.atk));

          // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ãªã‚‹ãƒ˜ãƒƒã‚¯ã‚¹å€™è£œã‚’å–å¾—ï¼ˆæ•µå›½ã®é¦–éƒ½ã¾ãŸã¯é ˜åœŸï¼‰
          let targetHexCandidates = [];
          targetTags.forEach((tTag) => {
            const enemyC = Game.countries[tTag];
            if (enemyC && !enemyC.dead) {
              if (enemyC.capital) targetHexCandidates.push(enemyC.capital);
              if (enemyC.provs.length > 0)
                targetHexCandidates.push(
                  enemyC.provs[Math.floor(Math.random() * enemyC.provs.length)]
                );
            }
          });

          // ãƒ¦ãƒ‹ãƒƒãƒˆã”ã¨ã®æ€è€ƒãƒ«ãƒ¼ãƒãƒ³
          // ãƒ©ãƒ³ãƒ€ãƒ ã«ä¸¦ã³æ›¿ãˆã¦ã€æ¯å›åŒã˜ãƒ¦ãƒ‹ãƒƒãƒˆã°ã‹ã‚Šå‹•ã‹ãªã„ã‚ˆã†ã«ã™ã‚‹
          const shuffledUnits = myUnits.sort(() => 0.5 - Math.random());

          for (const u of shuffledUnits) {
            if (actions >= maxActions) break;
            if (u.state === "moving" && u.path.length > 0) continue; // ç§»å‹•ä¸­ã¯æ”¾ç½®

            const neighbors = u.hex.adj;
            const enemyNeighbors = neighbors.filter(
              (n) =>
                n.owner !== tag &&
                n.owner !== "_SEA" &&
                Game.isWar(tag, n.owner)
            );

            // --- A. æ¥æ•µã—ã¦ã„ã‚‹å ´åˆ (æ”»æ’ƒ) ---
            if (enemyNeighbors.length > 0) {
              // çµ„ç¹”ç‡ãŒã‚ã‚‹ç¨‹åº¦ã‚ã‚Œã°æ”»æ’ƒ
              if (u.org > 20) {
                u.path = [
                  enemyNeighbors[
                    Math.floor(Math.random() * enemyNeighbors.length)
                  ],
                ];
                u.state = "moving";
                actions++;
              }
              continue;
            }

            // --- B. æ¥æ•µã—ã¦ã„ãªã„å ´åˆ (å‰ç·šã¸ã®ç§»å‹•) ---
            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆæ•µå›½ï¼‰ãŒå­˜åœ¨ã—ã€ã‹ã¤è‡ªåˆ†ãŒå¾…æ©Ÿä¸­ã§ã‚ã‚Œã°ç§»å‹•çµŒè·¯ã‚’æ¢ã™
            if (targetTags.length > 0 && u.state === "idle") {
              // æœ€ã‚‚è¿‘ã„ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’æ¢ã™
              let bestTarget = null;
              let minDist = 999999;

              for (const tHex of targetHexCandidates) {
                const d = (u.x - tHex.x) ** 2 + (u.y - tHex.y) ** 2;
                if (d < minDist) {
                  minDist = d;
                  bestTarget = tHex;
                }
              }

              if (bestTarget) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”¨ã®çµŒè·¯æ¢ç´¢é–¢æ•°(Input.findPath)ã‚’æµç”¨ã—ã¦çµŒè·¯ã‚’è¨ˆç®—
                // maxSearchã‚’å°‘ã—å°ã•ã‚ã«ã—ã¦è² è·å¯¾ç­–
                const path = Input.findPath(u.hex, bestTarget, tag, 500);
                if (path && path.length > 0) {
                  u.path = path;
                  u.state = "moving";
                  actions++;
                }
              }
            }
          }

          // å®£æˆ¦å¸ƒå‘Šãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—)
          if (
            enemies.length === 0 &&
            myUnits.length > 10 &&
            c.treeType === "GUNMA"
          ) {
            const neighbors = Game.getNeighbors(tag);
            const tree = DB.FocusTree[c.treeType];
            const isFocusTreeDone =
              c.completedFocuses.length >= tree.length * 0.5;
            if (
              isFocusTreeDone &&
              neighbors.length > 0 &&
              c.peaceTimer > 100 &&
              Math.random() < 0.1
            ) {
              const target =
                neighbors[Math.floor(Math.random() * neighbors.length)];
              if (!Game.isAlly(tag, target)) {
                setTimeout(() => Game.declareWar(tag, target), 1000);
              }
            }
          }
        },
      };
      document.addEventListener("DOMContentLoaded", () => Game.init());
    </script>
  </body>
</html>
